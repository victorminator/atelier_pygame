{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Atelier programmation de jeux vid\u00e9os Anim\u00e9 par Pottier Victor Th\u00e8mes abord\u00e9s Durant le cursus, nous travaillerons principalement trois th\u00e8mes : Culture G\u00e9n\u00e9rale de l'informatique et du jeu vid\u00e9o Initiation au langage Python Initiation au module Pygame Objectifs du programme Pourquoi l'atelier programmation de jeux vid\u00e9os ? Cr\u00e9er son propre jeu vid\u00e9o seul ou en \u00e9quipe Mettre en valeur l'enseignement de sp\u00e9cialit\u00e9 NSI au lyc\u00e9e D\u00e9velopper des comp\u00e9tences en programmation Apprendre en s'amusant Liste des chapitres Titre Dur\u00e9e C1 - Jeu vid\u00e9o : d\u00e9finition et fonctionnement 1 C2 - Le langage Python 4 C3 - Introduction \u00e0 la programmation avec Pygame 3 C4 - Programmation orient\u00e9e objet : classe Sprite 2 C5 - Programmer le jeu Pong 2 C6 - Cr\u00e9er des animations et autres techniques 1 C7 - Astuces pour programmer efficacement 1 C8 - Cr\u00e9er de la documentation disponible en ligne 2 C9 - Programmer le casse-briques 3 C10 - Programmer Crazy Taxi 4 C11 - FINAL : projets libres ?","title":"Atelier programmation de jeux vid\u00e9os"},{"location":"#atelier-programmation-de-jeux-videos","text":"Anim\u00e9 par Pottier Victor","title":"Atelier programmation de jeux vid\u00e9os"},{"location":"#themes-abordes","text":"Durant le cursus, nous travaillerons principalement trois th\u00e8mes : Culture G\u00e9n\u00e9rale de l'informatique et du jeu vid\u00e9o Initiation au langage Python Initiation au module Pygame","title":"Th\u00e8mes abord\u00e9s"},{"location":"#objectifs-du-programme","text":"Pourquoi l'atelier programmation de jeux vid\u00e9os ? Cr\u00e9er son propre jeu vid\u00e9o seul ou en \u00e9quipe Mettre en valeur l'enseignement de sp\u00e9cialit\u00e9 NSI au lyc\u00e9e D\u00e9velopper des comp\u00e9tences en programmation Apprendre en s'amusant","title":"Objectifs du programme"},{"location":"#liste-des-chapitres","text":"Titre Dur\u00e9e C1 - Jeu vid\u00e9o : d\u00e9finition et fonctionnement 1 C2 - Le langage Python 4 C3 - Introduction \u00e0 la programmation avec Pygame 3 C4 - Programmation orient\u00e9e objet : classe Sprite 2 C5 - Programmer le jeu Pong 2 C6 - Cr\u00e9er des animations et autres techniques 1 C7 - Astuces pour programmer efficacement 1 C8 - Cr\u00e9er de la documentation disponible en ligne 2 C9 - Programmer le casse-briques 3 C10 - Programmer Crazy Taxi 4 C11 - FINAL : projets libres ?","title":"Liste des chapitres"},{"location":"C2-Python/","text":"C2 - Programmer en Python Introduction Afin de cr\u00e9er des jeux vid\u00e9os, il faut savoir programmer. Ce chapitre vous initiera \u00e0 un langage de programmation facile \u00e0 prendre en main : Python. Quote La programmation n'est pas simplement la r\u00e9daction d'instructions pour un ordinateur. Il s'agit d'une fa\u00e7on de penser. Le bon programmeur pense comme un ordinateur. Il sait se mettre \u00e0 la place de l'ordinateur et peut simuler l'ex\u00e9cution d'un programme \u00e9tape par \u00e9tape rien que dans sa t\u00eate. Cependant, si vous \u00eates d\u00e9j\u00e0 \u00e0 l'aise avec le langage Python, vous pouvez directement passer au prochain chapitre. Cette page vous donnera quelques bases fondamentales pour programmer en Python. Mais il faut tout de m\u00eame savoir que la meilleure mani\u00e8re d'apprendre \u00e0 programmer, c'est la pratique. Nous vous invitons donc \u00e0 cr\u00e9er un compte et \u00e0 vous entrainer \u00e0 la programmation sur le site France IOI avant m\u00eame de commencer \u00e0 lire \u00e0 cette page. La d\u00e9finition des mots en gras pourra \u00eatre retrouv\u00e9e dans le glossaire en bas de page. 1 - Caract\u00e9ristiques du langage A. Langage interpr\u00e9t\u00e9 Python est un langage interpr\u00e9t\u00e9 , c'est-\u00e0-dire que votre code est traduit ligne apr\u00e8s ligne en langage machine (une suite de 0 et de 1 que l'ordinateur peut comprendre). En opposition \u00e0 la compilation , o\u00f9 tout votre code est traduit en une seule fois en langage machine. Le probl\u00e8me qui en \u00e9merge est le fait que les langages de programmation interpr\u00e9t\u00e9s sont plus lents que leurs confr\u00e8res compil\u00e9s. Toutefois, ils sont plus faciles \u00e0 d\u00e9boguer (trouver les bugs et les corriger) que les langages compil\u00e9s. B. Riche en modules et librairies Python poss\u00e8de de nombreuses librairies et modules , qui sont des ensembles d'outils non disponibles initialement (un peu comme des extensions), comme la librairie Pygame qui nous permettra de cr\u00e9er des jeux vid\u00e9os. C. Utilise l'indentation Ce qui d\u00e9marque Python de la plupart des autres langages, c'est qu'il exploite l'indentation pour d\u00e9limiter les diff\u00e9rents blocs de code . Alors que d'autres langages comme le C ou le Java utilise des accolades {}, Python utilise des suites d'espaces g\u00e9n\u00e9r\u00e9s par la touche de tabulation, ce qui le rend plus lisible pour un \u00eatre humain. Example Java Python public static void main ( String [] args ) { if ( 1 + 1 == 2 ) { System . out . println ( \"1 + 1 font 2\" ); } else { System . out . println ( \"Votre ordinateur est d\u00e9faillant.\" ); } } def main (): if 1 + 1 == 2 : print ( \"1 + 1 font 2\" ) else : print ( \"Votre ordinateur est d\u00e9faillant.\" ) Dans cet exemple, on remarque une accumulation d'accolades pour le langage Java afin de savoir \u00e0 quel bloc il appartient. Ces accolades sont remplac\u00e9es par des tabulations en Python. Vous remarquez sans doute que nous avons pourtant \u00e9galement utilis\u00e9 l'indentation pour Java en plus des accolades. Ces indentations n'ont en fait aucun effet sur le code au contraire du langage Python, l'utilisation d'espaces a simplement pour but rendre le code plus lisible. D. Typage dynamique Vous n'\u00eates pas contrait de d\u00e9clarer le type des variables (des sorte de bo\u00eetes qui servent \u00e0 m\u00e9moriser une valeur) que vous cr\u00e9ez, au contraire encore une fois du C et du Java. Car les variables peuvent changer de type. Prenons le code suivant qui affiche le contenu d'une variable nomm\u00e9e a : Example Java Python int a = 42 ; a = \"La r\u00e9ponse \u00e0 la question ultime.\" ; System . out . println ( a ); Sortie : error incompatible types String cannot be converted to int a = 42 a = \"La r\u00e9ponse \u00e0 la question ultime.\" print ( a ) Sortie : La r\u00e9ponse \u00e0 la question ultime. I\u00e7i, on cr\u00e9e une variable a et on lui affecte la valeur 42 qui est une valeur num\u00e9rique enti\u00e8re (type int ). Puis on lui affecte une nouvelle valeur qui est cette fois-\u00e7i une chaine de caract\u00e8res (type string ). Python n'a aucun probl\u00e8me pour g\u00e9rer ce cas de figure. En revanche, Java en est incapable, ce qui provoque ainsi une erreur. 2 - Installation A. Installer Python Pour pouvoir d\u00e9velopper en Python, il va vous falloir un interpr\u00e9teur Python. Pour cela, direction le site officiel du langage Python puis t\u00e9l\u00e9chargez la version la plus r\u00e9cente. B. Installer Visual Studio code Vous pouvez programmer depuis votre bloc-notes mais il est plus efficace de programmer depuis un IDE (environnement de d\u00e9veloppement). Il en existe plusieurs mais nous choisirons VS code, que vous pourrez retrouver et t\u00e9l\u00e9charger sur ce site . C. Installer l'extension Python Une fois que vous aurez install\u00e9 et lanc\u00e9 VS code, il est fortement recommand\u00e9 d'installer l'extension Python. Vous pourrez retrouver et t\u00e9l\u00e9chargez diff\u00e9rentes extensions dans le barre de navigation gauche de VS code (les quatres petits cubes). Cliquez sur le bouton \"installer\" bleu et cela devrait d\u00e9buter l'installation de l'extension. D. Cr\u00e9er un nouveau projet Lorsque vous programmerez, vous travaillerez g\u00e9n\u00e9ralement dans un r\u00e9pertoire (ou dossier). Pour cr\u00e9er un nouveau projet, cr\u00e9ez simplement un nouveau r\u00e9pertoire puis ouvrez-le \u00e0 partir de VS code. Afin d'ouvrir un r\u00e9pertoire, il faut cliquer sur l'onglet \"fichier\" en haut \u00e0 gauche, puis cliquez sur l'option \"ouvrir un r\u00e9pertoire\" dans le menu d\u00e9roulant (il s'agit de la 5e option depuis le haut). Vous pourrez ensuite cr\u00e9er des fichiers code source Python (.py) dans lesquels vous \u00e9crirez votre code \u00e0 partir de l'\u00e9diteur, et ce tr\u00e8s facilement. Il suffit d'aller dans le menu \u00e0 gauche et cliquer sur l'ic\u00f4ne de fichier avec un +. Nommez votre fichier et n'oubliez pas d'ajouter l'extension .py \u00e0 la fin du nom. Comme montr\u00e9 \u00e7i-dessous : Et cela cr\u00e9e un fichier code source Python dans le r\u00e9pertoire que vous avez ouvert ! Maintenant que nous avons un fichier dans lequel coder, nous pouvons enfin commencer \u00e0 programmer. 3 - Afficher du texte, variables et ex\u00e9cution A. Hello world! Tr\u00e8s souvent, la premi\u00e8re chose qu'on veut faire lorsqu'on apprend un nouveau langage de programmation, c'est d'afficher le texte \"Hello world!\". En Python, on affiche du texte gr\u00e2ce \u00e0 l'instruction print(valeur) en rempla\u00e7ant valeur par ce que vous souhaitez afficher. Ainsi pour afficher \"Hello world!\", on \u00e9crira : print ( \"Hello world!\" ) B. Ex\u00e9cuter son programme Une fois cette instruction \u00e9crite dans votre fichier .py, il ne reste plus qu'\u00e0 l'ex\u00e9cuter. Sur VS code, un moyen d'ex\u00e9cuter le fichier actuellement \u00e9dit\u00e9 consiste \u00e0 cliquer sur l'onglet \"Ex\u00e9cuter\" situ\u00e9 au m\u00eame niveau que l'onglet \"Fichier\" puis de choisir l'option sans d\u00e9bogage. L'ordinateur ex\u00e9cutera ainsi tout ce que vous lui avez ordonn\u00e9 de faire dans votre programme. Note Notez que le texte Hello world! est entour\u00e9 par des guillemets. Les guillemets servent \u00e0 diff\u00e9rencier les chaines de caract\u00e8res des noms de variables. Nous explorerons la notion de chaine de caract\u00e8re vers la fin du chapitre. C. Les variables Mais qu'est-ce qu'une variable ? Une variable est, pour donner une d\u00e9finition simple, une bo\u00eete nomm\u00e9e par un identifiant et qui contient une valeur. Par exemple : impair = 5 I\u00e7i nous avons cr\u00e9\u00e9 une variable que nous avons nomm\u00e9 impair et \u00e0 laquelle nous avons affect\u00e9 le nombre 5. Attention, le signe = en Python ne symbolise pas une \u00e9galit\u00e9 math\u00e9matique mais une affectation . Nous verrons comment tester une \u00e9galit\u00e9 dans la 5e partie de ce chapitre. Par cons\u00e9quent, le contenu d'une variable peut \u00eatre modifi\u00e9 (d'o\u00f9 le nom 'variable'). De plus, nous pouvons utiliser son nom (alias son identifiant) pour acc\u00e9der \u00e0 la valeur qu'elle contient, comme nous pouvons le constater dans l'exemple \u00e7i-dessous : impair = 5 impair = impair - 2 print ( impair ) Warning Attention aux noms que vous donnez \u00e0 vos variables ! Les espaces, parenth\u00e8ses, guillemets, les op\u00e9rateurs + - = % / , et la plupart des caract\u00e8res qui ne sont pas alphanum\u00e9riques sont interdits. Vous pouvez mettre des chiffres dans le nom de votre variable tant qu'il ne s'agit pas du caract\u00e8re situ\u00e9 au tout d\u00e9but du nom. Tip Il est recommand\u00e9 de donner des noms significatifs \u00e0 vos variables, c'est-\u00e0-dire des noms qui illustrent le contenu de la variable. Par exemple une variable qui contient toujours un nombre impair devrait \u00eatre nomm\u00e9e impair , comme dans l'exemple. Si le nom de votre variable s'\u00e9crit sur plusieurs mots, vous pouvez utiliser des underscore _ afin de remplacer les espaces ( snake_case ). Vous pouvez \u00e9galement employer l'\u00e9criture camelCase . 4 - Faire des calculs A. Addition et soustraction Dans le dernier programme, nous avons utilis\u00e9 la soustraction avec impair - 2 . En Python, comme dans la quasi-totalit\u00e9 des langages de programmation, il est possible d'effectuer des op\u00e9rations math\u00e9matiques. Nous pouvons par exemple additionner et soustraire des valeurs gr\u00e2ce aux op\u00e9rateurs + et - : total = 50 vaches = 11 poules = 23 cochons = total - vaches - poules mammiferes = vaches + cochons print ( mammiferes ) Le r\u00e9sultat obtenu est \\(11 + 50 - 11 - 23 = 27\\) . B. Multiplication et division La multiplication s'effectue avec un ast\u00e9risque * tandis que la division classique s'effectue avec un slash / . n = 10 somme_entiers = ( n + 1 ) * n / 2 print ( somme_entiers ) Maths somme_entiers abrite en fait la formule permettant de calculer les n premiers entiers positifs cons\u00e9cutifs : \\(\\frac{n}{2}(n + 1)\\) . Par exemple pour calculer \\(n = 6\\) , soit \\(1 + 2 + 3 + 4 + 5 + 6\\) . Il suffit d'appliquer la formule : \\(S = \\frac{6}{2}(6 + 1)\\) . Par cons\u00e9quent, il ne reste plus qu'\u00e0 simplifier le calcul : \\(S = 3 \\times 7 = 21\\) . Et voil\u00e0 ! Le tour est jou\u00e9. Plus facile que d'additionner \\(1 + 2 + 3 + 4 + 5 + 6\\) , non ? C. Division euclidienne et reste Vous vous rappelez peut-\u00eatre de l'ancienne division que vous effectuiez en primaire. Celle qui permet d'obtenir un quotient et un reste. Il s'agit de la division euclidienne. Par exemple, \\(37 \\div 8 = 8 \\times 4 + 5\\) . I\u00e7i, le quotient de la division \\(37 \\div 8\\) est 4, tandis que le reste obtenu est 5. Pour obtenir le quotient d'une division euclidienne en Python, il suffit d'\u00e9crire un double slash // entre les deux nombres que l'on souhaite diviser : position = 37 // 8 print ( position ) Quant au reste d'une division euclidienne, il suffit de remplacer le double slash // par un % . pas = 37 % 8 D. Puissances, racines carr\u00e9es et modules Pour \u00e9lever un nombre \u00e0 une puissance en Python, il suffit d'\u00e9crire nombre ** puissance en remplacant nombre par le nombre que vous souhaitez utiliser et puissance par la puissance \u00e0 laquelle vous souhaitez l'\u00e9lever. On utilise donc le double ast\u00e9risque ** pour \u00e9lever \u00e0 une puissance : a = 4 b = 3 res = ( a + b ) ** 3 print ( res ) Remarquons l'utilisation des parenth\u00e8ses (a + b) , en informatique tout comme en math\u00e9matiques, il existe une priorit\u00e9 op\u00e9ratoire . L'utilisation des parenth\u00e8ses permet de donner une priorit\u00e9 \u00e0 un groupe d'op\u00e9rations. Sachant que sont calcul\u00e9s dans l'ordre : puissances / racines => multiplication / division => addition / soustraction Pour pouvoir calculer des racines, la m\u00e9thode sera l\u00e9g\u00e8rement diff\u00e9rente. Nous aurons besoin d'une fonction appartenant \u00e0 un module pr\u00e9-install\u00e9 : le module math . Pour pouvoir utiliser le contenu d'un module, il existe diff\u00e9rentes techniques. La premi\u00e8re, qui est la plus recommand\u00e9e \u00e0 utiliser, consiste \u00e0 importer le module et mentionner le nom du module chaque fois qu'on souhaite acc\u00e9der \u00e0 un outil appartenant au module : import math nombre_pi = math . pi print ( nombre_pi ) Dans l'exemple \u00e7i-dessus, nous avons import\u00e9 le module gr\u00e2ce \u00e0 l'instruction import math . Puis nous avons acc\u00e9d\u00e9 \u00e0 la valeur \\(\\pi\\) \u00e0 partir du module math avec l'instruction math.pi . La syntaxe pour utiliser un objet appartenant \u00e0 un module est donc nom_module.nom_objet . Le deuxi\u00e8me moyen d'acc\u00e9der au contenu d'un module est avec le mot-cl\u00e9 from . Celui-\u00e7i permet d'acc\u00e9der directement \u00e0 une ou plusieurs ressources du module sans avoir \u00e0 constamment sp\u00e9cifier le nom du module : from math import sqrt racine_16 = sqrt ( 16 ) print ( racine_16 ) Nous venons d'ailleurs tout juste de montrer comment calculer la racine carr\u00e9e d'un nombre en Python. La fonction sqrt(nombre) en rempla\u00e7ant nombre par le nombre auquel vous souhaitez calculer la racine carr\u00e9e. Info Il est conventionnel d'\u00e9crire les instructions import au tout d\u00e9but de votre programme. N'importez pas des modules en plein milieu de vos programmes ! Nous pouvons \u00e9galement importer l'int\u00e9gralit\u00e9 du contenu du module en une seule fois gr\u00e2ce au mot-cl\u00e9 from et le caract\u00e8re joker * : from math import * racine_pi = sqrt ( pi ) print ( racine_pi ) Nous pouvons utiliser sans probl\u00e8me la fonction sqrt et la valeur pi dans ce dernier exemple. Cependant cette m\u00e9thode n'est pas recommand\u00e9e car nous importons tout le contenu du module sans savoir pr\u00e9cis\u00e9ment ce que l'on importe. Warning Importer l'int\u00e9gralit\u00e9 du contenu d'un module peut provoquer des ambigu\u00eft\u00e9s . C'est-\u00e0-dire que deux fonctions ou deux variables qui ont deux r\u00f4les diff\u00e9rents risquent de porter le m\u00eame nom. Par exemple, si vous d\u00e9cidez de cr\u00e9er une variable pi apr\u00e8s avoir \u00e9crit l'instruction from math import * , alors vous perdrez la valeur initiale de pi import\u00e9e du module math. E. Nombres \u00e0 virgules En affichant la valeur de math.pi , vous avez peut-\u00eatre remarqu\u00e9 le . \u00e0 la suite du 3. Lorsqu'on \u00e9crit des nombres en Python, le . est l'\u00e9quivalent d'une virgule. Ainsi, \\(2,5\\) s'\u00e9crit 2.5 en Python. Les nombres \u00e0 virgules sont appel\u00e9s float , nombres flottants en fran\u00e7ais. Bug Il n'est pas efficace de tester des \u00e9galit\u00e9s (\u00e9galit\u00e9s que l'on \u00e9tudiera dans la partie suivante) quand on y inclut des nombres flottants. En essayant de calculer 0.1 + 0.2 et sqrt(2) * sqrt(2) , vous remarquerez que Python peut fournir des r\u00e9sultats impr\u00e9visibles quand il travaille avec des nombres \u00e0 virgule. 5 - Valeurs bool\u00e9enes, comparaisons et prises de d\u00e9cisions A. Les valeurs bool\u00e9ennes En plus des nombres, il existe un autre type de valeur en informatique : les valeurs bool\u00e9ennes. Il s'agit d'un type ne pouvant prendre que deux valeurs diff\u00e9rentes, True ou False . Elles sont notamment utiles pour la prise de d\u00e9cision de l'ordinateur. Pour donner une valeur bool\u00e9enne \u00e0 une variable, c'est tr\u00e8s simple : toujours_vrai = True toujours_faux = False Nous pouvons m\u00eame effectuer des op\u00e9rations sur les valeurs bool\u00e9ennes. Le not permet d'inverser la valeur d'un bool\u00e9en. not True devient False et not False devient True . a = True b = False print ( not a ) print ( not b ) Nous pouvons \u00e9galement utiliser l'op\u00e9ration or qui prend deux valeurs bool\u00e9ennes et a pour r\u00e9sultat True si au moins l'une des deux valeurs vaut True . a = True b = False c = b or a d = c or a e = False or b print ( a , b , c , d , e ) c vaut True car a est vrai. d vaut True car c est vrai. e vaut False car ni False ni b ne sont vrais. La derni\u00e8re op\u00e9ration que nous pouvons utiliser est and . Comme or , and prend deux valeurs bool\u00e9ennes mais a pour r\u00e9sultat True uniquement si ces deux valeurs valent True . a = True or False b = False and not True c = a and True d = c and b e = c and d or b print ( a , b , c , d , e ) B. Conditions if En Python, tout comme dans la plupart des langages de programmation, certaines instructions doivent pouvoir \u00eatre ex\u00e9cut\u00e9es sous une certaine condition . C'est le r\u00f4le de l'instruction if . toujours_vrai = True toujours_faux = False if toujours_vrai : print ( \"toujours_vrai est vrai\" ) if toujours_faux : print ( \"toujours_faux est vrai\" ) En ex\u00e9cutant le code \u00e7i-dessus, l'ordinateur n'affiche que \"toujours_vrai est vrai\". Car un bloc d'instructions appartennant \u00e0 un if n'est pris en compte que si la valeur bool\u00e9ene qui suit son if vaut True . La syntaxe pour \u00e9crire une condition if est donc : if condition : #bloc de code Attention cependant \u00e0 ne pas oublier les : \u00e0 la fin de l'instruction if ! Rappel Rappelons que Python utilise l'indentation pour d\u00e9limiter les blocs de code. Ainsi, pour marquer la fin et sortir d'un bloc de code, il suffit d'effacer la tabulation. Au contraire, pour ajouter un nouveau bloc (\u00e0 cause d'un if , d'un for , d'un while ou encore d'un def ), il suffit d'ajouter une tabulation. Nous pouvons \u00e9videmment combiner la condition avec les op\u00e9rations que nous avons \u00e9tudi\u00e9 \u00e0 la pr\u00e9c\u00e9dente partie. Par exemple : a = True b = True c = False if a or c : print ( \"Au moins 'a' ou 'c' vaut True\" ) if a and b : print ( \"'a' et 'b' valent tous les deux True\" ) if not b and c : print ( \"L'inverse de 'b' et 'c' valent tous les deux True\" ) C. Op\u00e9rations de comparaison Il est possible de comparer deux valeurs afin d'obtenir un bool\u00e9en. Il existe six op\u00e9rations de comparaisons en Python ( > , < , >= , <= , == , != ). Avec == qui teste une \u00e9galit\u00e9 entre deux valeurs, et != qui teste une in\u00e9galit\u00e9 entre deux valeurs. Il est possible de comparer deux valeurs num\u00e9riques. Par exemple : strictement_superieur = 7 > 5 superieur_ou_egal = 3 >= 3 strictement_inferieur = 10 < 4 * 2 inferieur_ou_egal = - 15 <= 12 - 10 egal = 2 + 2 == 22 pas_egal = 0 != 1 print ( strictement_superieur ) print ( superieur_ou_egal ) print ( strictement_inferieur ) print ( inferieur_ou_egal ) print ( egal ) print ( pas_egal ) \\(7 > 5\\) est vrai donc on obtient True . \\(3 >= 3\\) est vrai donc on obtient aussi True . Cependant, \\(10 < 8\\) est faux donc on obtient False . \\(-15 <= 2\\) est vrai donc on obtient True . \\(4 = 22\\) est faux donc on obtient False . Enfin, 0 est en effet pas \u00e9gal \u00e0 1 donc on obtient True . D. L'instruction else et elif Supposons le cas suivant. Si nous sommes la matin, l'ordinateur devra afficher Bonjour . Si nous ne sommes pas le matin, l'ordinateur devra afficher Bonsoir . Pour faire cela, on pourrait utiliser l'op\u00e9ration not comme \u00e7i-dessous : matin = True if matin : print ( \"Bonjour\" ) if not matin : print ( \"Bonsoir\" ) Mais cela est r\u00e9p\u00e9titif ! if not matin est ex\u00e9cut\u00e9 si if matin n'est pas ex\u00e9cut\u00e9. En Python on peut remplacer cela avec une instruction else (signifiant 'sinon') \u00e0 la suite d'une instruction if afin d'ex\u00e9cuter un bloc de code sous condition que le if qui le pr\u00e9c\u00e8de porte une condition fausse. On peut ainsi \u00e9crire : matin = False if matin : print ( \"Bonjour\" ) else : print ( \"Bonsoir\" ) Mais supposons maintenant qu'il y ait un troisi\u00e8me cas o\u00f9 l'ordinateur devra afficher \"Bonne nuit\" \u00e0 la place, et qu'on utilise un nouveau bool\u00e9en nuit . On pourrait essayer : matin = False nuit = True if matin : print ( \"Bonjour\" ) else : print ( \"Bonsoir\" ) if nuit : print ( \"Bonne nuit\" ) Cela ne fonctionne pas comme nous l'avions pr\u00e9vu, l'ordinateur affiche deux r\u00e9sultats alors que nous n'en n'attendons qu'un seul ! Le probl\u00e8me dans le programme pr\u00e9c\u00e9dent est que l'instruction if nuit est ind\u00e9pendante de l'instruction if matin , alors que \u00e7a ne devrait pas \u00eatre le cas. Pour r\u00e9m\u00e9dier \u00e0 cela, Python propose le mot-cl\u00e9 elif , diminutif de else if (signifiant sinon si). Corrigeons donc le programme pr\u00e9c\u00e9dent : matin = False nuit = True if matin : print ( \"Bonjour\" ) elif nuit : print ( \"Bonne nuit\" ) else : print ( \"Bonsoir\" ) Si matin est vrai, alors on ignore tout le reste et on affiche Bonjour . Sinon, si nuit est vrai alors on ignore le reste et on affiche Bonne nuit . Dans tous les autres cas, on affichera Bonsoir . Notez que vous pouvez mettre autant d'instructions elif \u00e0 la suite d'une instruction if . Cependant else et elif ne sont pas obligatoires pour pouvoir utiliser une instruction if . Rappelons-nous simplement de la structure suivante : if condition : # 1er cas elif autre_condition : # 2e cas elif nouvelle_condition : # 3e cas else : # Tous les autres cas Vous peut-\u00eatre d\u00e9j\u00e0 remarqu\u00e9 les di\u00e8ses # dans les programmes propos\u00e9s. Les di\u00e8ses permettent d'\u00e9crire \u00e0 leur suite des commentaires. Les commentaires sont des suites de caract\u00e8res que l'ordinateur ne prend pas en compte. Ils servent simplement aux \u00eatres humains qui lisent le code, pour pouvoir se rep\u00e9rer ou encore pr\u00e9ciser le r\u00f4le d'une instruction. Avec les connaissances que vous avez acquises, vous devriez \u00eatre capable d'\u00e9crire un programme qui : Challenge Enonc\u00e9 Correction exploite une variable heure qui devrait \u00eatre un entier compris entre 1 et 12 exploite un bool\u00e9en apres-midi qui d\u00e9termine s'il s'agit d'une heure de l'apr\u00e8s-midi ou non Affiche un texte en fonction du moment de la journ\u00e9e obtenu. \"Good morning\" si il est entre 5h et 10h inclus \"Bon app\u00e9tit\" si il est entre 11h et 13h inclus \"Good afternoon\" si il est entre 14h et 17h inclus \"Good evening\" si il est entre 18h et 20h inclus \"Sweet dreams\" si il est entre 21h et 4h inclus heure = 3 apres_midi = True if apres_midi : heure = heure + 12 if heure < 5 or heure > 20 : print ( \"Sweet dreams\" ) elif heure <= 10 : print ( \"Good morning\" ) elif heure < 14 : print ( \"Bon app\u00e9tit\" ) elif heure <= 17 : print ( \"Good afternoon\" ) else : print ( \"Good evening\" ) Mais comment savoir que notre programme est correct pour toutes les heures ? Nous verons cela dans la prochaine partie. 6 - Utiliser des listes et r\u00e9p\u00e9ter des instructions A. Cr\u00e9er une liste et acc\u00e9der \u00e0 un de ses \u00e9l\u00e9ments Supposons que nous souhaitons une variable qui contienne plusieurs valeurs diff\u00e9rentes, comment proc\u00e8derait-on ? Avec des listes, mon cher ami ! Une liste peut contenir aucune valeur, tout comme elle peut en contenir une, deux, trois, douze, cinquante ou m\u00eame un million. On \u00e9crit le contenu d'une liste entre crochets [] et on s\u00e9pare les valeurs \u00e0 l'int\u00e9rieur par des virgules : liste = [1, 2, 3, 4] liste_vide = [] liste_carres = [1, 4, 9, 16, 25, 36] liste_0 = [0] * 100 liste_fusion = liste + liste_carres Comme nous pouvons le remarquer, nous pouvons \u00e9galement appliquer l'addition et la multiplication sur les listes. L'addition est en fait une op\u00e9ration de concat\u00e9nation entre deux listes, c'est-\u00e0-dire qu'on va fusionner les deux listes en une seule. L'op\u00e9rateur * peut aussi \u00eatre utilis\u00e9. Il sert \u00e0 'r\u00e9p\u00e9ter' le contenu d'une liste un nombre entier de fois, \u00e0 concat\u00e9ner une liste avec une copie d'elle-m\u00eame un nombre entier de fois. Par exemple, ma_liste * 4 revient \u00e0 faire ma_liste + ma_liste + ma_liste + ma_liste . Les listes fonctionnent avec un syst\u00e8me d'indices. C'est-\u00e0-dire que chaqe valeur dans la liste est num\u00e9rot\u00e9e afin de pouvoir l'identifier. A chaque valeur est associ\u00e9e un num\u00e9ro (commun\u00e9ment appel\u00e9 indice) allant de 0 au nombre d'\u00e9l\u00e9ments qu'il y a dans la liste - 1, en accordance avec sa position dans la liste : l'\u00e9l\u00e9ment le plus \u00e0 gauche sera num\u00e9rot\u00e9e 0, celui \u00e0 sa droite aura comme indice 1, le suivant 2, et ainsi de suite. On peut donc acc\u00e9der \u00e0 une valeur de la liste par son indice gr\u00e2ce \u00e0 la notation liste[indice] . Supposons une liste d'entiers et que l'on souhaite additionner la premi\u00e8re valeur avec la 3e, la 5e ainsi que la derni\u00e8re : entiers = [ 29 , 47 , 1 , 18 , - 53 , 10 , 101 , 65 , - 42 ] calcul = entiers [ 0 ] + entiers [ 2 ] + entiers [ 4 ] + entiers [ - 1 ] print ( calcul ) Warning Ne jamais oublier que l'ordinateur commence \u00e0 compter \u00e0 partir de 0 ! Donc il vous faudra soustraire 1 au nombre auquel vous pensez \u00e0 chaque fois que vous souhaitez acc\u00e9der \u00e0 un \u00e9l\u00e9ment d'une liste. Le premier \u00e9l\u00e9ment correspond \u00e0 0, le seizi\u00e8me correspond \u00e0 15, le centi\u00e8me correspond \u00e0 99, etc... Distinguons la notation entiers[-1] . Celle-ci permet d'acc\u00e9der au dernier \u00e9l\u00e9ment d'une liste. Evidemment, on aurait pu aussi \u00e9crire entiers[8] dans le dernier exemple, mais et si le dernier \u00e9l\u00e9ment de la liste est le 3571691e \u00e9l\u00e9ment ? Il est plus simple d'\u00e9crire entiers[-1] En donnant un indice n\u00e9gatif, on acc\u00e8de aux \u00e9l\u00e9ments \u00e0 partir de la droite au lieu de la gauche. Ainsi, entiers[-1] fait r\u00e9f\u00e9rence au dernier \u00e9l\u00e9ment d'une liste (celui le plus \u00e0 droite), entiers[-2] fait r\u00e9f\u00e9rence \u00e0 l'avant-dernier \u00e9l\u00e9ment, entiers[-3] \u00e0 celui \u00e0 sa gauche, et ainsi de suite. B. M\u00e9thodes et fonctions associ\u00e9es aux listes Pour obtenir la taille d'une liste, on utilise la fonction len , diminutif de length signifiant longueur en anglais. Par exemple len([0, 10, 20, 30]) renvoie 4 car il y a 4 \u00e9l\u00e9ments dans la liste pass\u00e9 en param\u00e8tre (ou argument). La fonction min permet d'obtenir la plus petite valeur d'une liste. Par exemple min([18, 31, 10, 19, 22]) renvoie 10. A l'opposition de la fonction min , la fonction max permet d'obtenir la plus grande valeur d'une liste. Par exemple max([18, 31, 10, 19, 22]) renvoie 31. Pour calculer facilement la somme de toutes les valeurs \u00e0 l'int\u00e9rieur d'une liste, on peut utiliser la fonction sum . Par exemple, sum([18, 31, 10, 19, 22]) renvoie 100. Nous pouvons effectuer un test d'appartenance gr\u00e2ce au mot-cl\u00e9 in . Par exemple, 23 in [19, 87, 45, 23, 12] vaut True car 23 est \u00e0 l'int\u00e9rieur de la liste mentionn\u00e9e. En revanche, 24 in [19, 87, 45, 23, 12] vaut False car il n'y a aucun 24 \u00e0 l'int\u00e9rieur de cette m\u00eame liste. Nous pouvons ajouter un \u00e9l\u00e9ment \u00e0 la fin d'une liste gr\u00e2ce \u00e0 la m\u00e9thode nom_liste.append(valeur) en rempla\u00e7ant nom_liste par le nom que vous avez donn\u00e9 \u00e0 votre liste, et valeur par l'\u00e9l\u00e9ment que vous souhaitez ajouter : factorielles = [ 1 , 2 , 6 , 24 , 120 ] factorielles . append ( factorielles [ - 1 ] * 6 ) print ( factorielles ) Similairement, nous pouvons supprimer un \u00e9l\u00e9ment d'une liste gr\u00e2ce la m\u00e9thode nom_liste.remove(valeur) en rempla\u00e7ant nom_liste par le nom que vous avez donn\u00e9 \u00e0 votre liste et valeur par l'\u00e9l\u00e9ment que vous souhaitez supprimer : factorielles = [ 1 , 2 , 6 , 24 , 120 ] factorielles . remove ( 6 ) print ( factorielles ) On peut obtenir l'indice associ\u00e9 \u00e0 un \u00e9l\u00e9ment gr\u00e2ce \u00e0 la m\u00e9thode nom_liste.index(valeur) en proc\u00e9dant de la m\u00eame mani\u00e8re que les deux m\u00e9thodes pr\u00e9c\u00e9dentes : factorielles = [ 1 , 2 , 6 , 24 , 120 ] indice_24 = factorielles . index ( 24 ) print ( indice_24 ) Enfin, il est possible de supprimer une valeur (tout en ayant l'option de la sauvgarder dans une variable) \u00e0 partir de son indice gr\u00e2ce \u00e0 la m\u00e9thode nom_liste.pop(indice) : factorielles = [ 1 , 2 , 6 , 24 , 120 ] derniere_valeur = factorielles . pop ( - 1 ) print ( factorielles ) print ( derniere_valeur ) C. Modifier une valeur \u00e0 l'int\u00e9rieur d'une liste Il est possible de modifier une valeur qui est situ\u00e9e \u00e0 l'int\u00e9rieur d'une liste gr\u00e2ce \u00e0 l'\u00e9criture nom_liste[indice] = nouvelle_valeur en rempla\u00e7ant nom_liste par le nom que vous avez donn\u00e9 \u00e0 votre liste, indice par l'indice associ\u00e9e \u00e0 la valeur que vous souhaitez modifier, et nouvelle_valeur par la nouvelle valeur que doit porter l'\u00e9l\u00e9ment s\u00e9lectionn\u00e9. prix = [ 12.99 , 14.50 , 3.00 , 20.30 , 8.99 ] prix [ 0 ] += 3 prix [ 1 ] -= 5 prix [ 2 ] *= 2 prix [ 3 ] /= 2 prix [ 4 ] = 7.99 print ( prix ) Dans l'exemple \u00e7i-dessus, nous avons modifi\u00e9 individuellement chacun des \u00e9l\u00e9ments de la liste prix . Vous vous demandez peut-\u00eatre \u00e0 quoi corresponds les signes += , -= , *= et /= . Il s'agit d'une affectation particuli\u00e8re. Ces affectations reprennent la valeur initiale de la variable et y effectuent une op\u00e9ration en fonction de l'op\u00e9rateur (+, -, *, /) \u00e9crit. Par exemple : prix = 10 reduction = 2.5 prix = prix - reduction print ( prix ) Fait strictement la m\u00eame chose que : prix = 10 reduction = 2.5 prix -= reduction print ( prix ) C'est le m\u00eame principe pour les autres op\u00e9rateurs : prix = 10 prix = prix + 2 # Signifie strictement la m\u00eame chose que prix = 10 prix += 2 prix = 8 prix = prix * 5 # Signifie strictement la m\u00eame chose que prix = 8 prix *= 5 prix = 24 prix = prix / 6 # Signifie strictement la m\u00eame chose que prix = 24 prix /= 6 Cette technique permet ainsi de simplifier l'\u00e9criture. D. La boucle for Il peut arriver qu'on veuille r\u00e9p\u00e9ter la m\u00eame chose un nombre connu de fois. C'est le r\u00f4le de la boucle for . La boucle for traditionnelle en Python s'\u00e9crit : for variable in range ( nb_fois ): # bloc de code \u00e0 r\u00e9p\u00e9ter nb_fois Ne pas oublier qu'il faut remplacer nb_fois par un entier repr\u00e9sentant le nombre de fois que vous souhaitez r\u00e9p\u00e9ter le bloc de code \u00e0 l'int\u00e9rieur de la boucle. Vous pouvez nommer variable comme vous le souhaitez, tant que le nom n'a pas d\u00e9j\u00e0 \u00e9t\u00e9 pris par une autre variable ou fonction existante. Proposons donc une exp\u00e9rience : for i in range ( 10 ): print ( i ) Nous venons donc utiliser la variable i initialis\u00e9e par la boucle dans le bloc associ\u00e9. Attention cependant \u00e0 ne pas l'utiliser en dehors de celle-\u00e7i ! Comme nous pouvons le voir, i commence par prendre la valeur 0, puis elle augmente de 1 jusqu'\u00e0 ce qu'elle atteigne 9. Cela ne vous rappelle rien ? Mais oui ! La fa\u00e7on dont les \u00e9l\u00e9ments d'une liste sont num\u00e9rot\u00e9es, bien s\u00fbr ! Nous verrons plus bas que les boucles for s'av\u00e9rent d'ailleurs efficaces pour parcourir une liste permettant donc d'acc\u00e9der \u00e0 chacun de ses \u00e9l\u00e9ments dans l'ordre et ainsi d'effectuer des m\u00eames op\u00e9rations sur ceux-ci. Autrement, lorsqu'on cr\u00e9e une boucle, nous sommes contraints de sp\u00e9cifier la fin de cette boucle. Mais si nous ne souhaitons pas que la boucle d\u00e9marre \u00e0 0, c'est possible ! Nous pouvons sp\u00e9cifier le valeur initiale de la variable exploit\u00e9e par la boucle et m\u00eame le pas effectu\u00e9 (la valeur que l'on ajoute \u00e0 la variable \u00e0 la fin de chaque it\u00e9ration) avec la syntaxe suivante : for variable in range ( debut , fin , pas ): # Bloc de code \u00e0 r\u00e9p\u00e9ter Voi\u00e7i un cas d'usage qui nous permet d'afficher tous les nombres pairs de 42 \u00e0 120 : for pair in range ( 42 , 120 + 1 , 2 ): print ( pair ) Warning 120 + 1 repr\u00e9sente une certaine importance car il rappelle que le nombre de fin d'une boucle est exclu. La boucle for var in range(10): prendra chaque valeur \u00e0 partir de 0 jusqu'\u00e0 10 mais jamais 10 en lui-m\u00eame ! E. Parcourir une liste Reprenons le programme qui affiche un texte diff\u00e9rent en fonction du moment de la journ\u00e9e : heure = 3 apres_midi = True if apres_midi : heure = heure + 12 if heure < 5 or heure > 20 : print ( \"Sweet dreams\" ) elif heure <= 10 : print ( \"Good morning\" ) elif heure < 14 : print ( \"Bon app\u00e9tit\" ) elif heure <= 17 : print ( \"Good afternoon\" ) else : print ( \"Good evening\" ) Nous ne testons qu'un seul cas dans l'exemple \u00e7i-dessus mais et si nous voulions tester plusieurs cas en une seule fois ? Cela est rendu possible gr\u00e2ce \u00e0 l'association d'une liste avec une boucle for . Par exemple, si nous souhaitons tester les valeurs : heures = [ 3 , 10 , 7 , 1 , 5 , 12 ] apres_midi = [ True , False , True , False , True , False ] Les deux listes sont de m\u00eame longueur, une valeur bool\u00e9ene et une heure sont reli\u00e9es par le fait qu'ils partagent le m\u00eame indice dans leur liste respective. Par exemple, heures[2] est une heure de l'apr\u00e8s-midi puisque apres_midi[2] vaut True . Maintenant, il faut effectuer un parcours de liste. Comme les \u00e9l\u00e9ments d'une liste sont num\u00e9rot\u00e9s par des indices croissants, on peut utiliser une boucle for pour g\u00e9n\u00e9rer chaque indice et ainsi avoir acc\u00e8s \u00e0 chacun des \u00e9l\u00e9ments par leur indice. Ce qui nous permet de tester chaque valeur. heures = [ 3 , 10 , 7 , 1 , 5 , 12 ] apres_midi = [ True , False , True , False , True , False ] for i in range ( len ( heures )): if apres_midi [ i ]: heures [ i ] += 12 if heures [ i ] < 5 or heures [ i ] > 20 : print ( heures [ i ], \"Sweet dreams\" ) elif heures [ i ] <= 10 : print ( heures [ i ], \"Good morning\" ) elif heures [ i ] < 14 : print ( heures [ i ], \"Bon app\u00e9tit\" ) elif heures [ i ] <= 17 : print ( heures [ i ], \"Good afternoon\" ) else : print ( heures [ i ], \"Good evening\" ) Le programme \u00e7i-dessus effectue un parcours par indice, mais nous pouvons \u00e9galement effectuer un parcours par \u00e9l\u00e9ment : heures = [ 15 , 10 , 19 , 1 , 17 , 12 ] for element in heures : if element < 5 or element > 20 : print ( element , \"Sweet dreams\" ) elif element <= 10 : print ( element , \"Good morning\" ) elif element < 14 : print ( element , \"Bon app\u00e9tit\" ) elif element <= 17 : print ( element , \"Good afternoon\" ) else : print ( element , \"Good evening\" ) I\u00e7i, on n'acc\u00e8de pas \u00e0 des indices mais directement aux \u00e9l\u00e9ments d'une liste. Cependant, il y a quelques d\u00e9savantages, par exemple on perd la possibilit\u00e9 d'acc\u00e9der \u00e0 des \u00e9l\u00e9ments d'autres listes comme apres_midi . De plus en examinant les deux cas suivants, o\u00f9 nous essayons d'\u00e9lever au cube chaque nombre de la liste : cubes = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] for i in range ( len ( cubes )): cubes [ i ] = cubes [ i ] ** 3 print ( cubes ) cubes = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] for nombre in cubes : nombre = nombre ** 3 print ( cubes ) On remarque que dans le parcours par \u00e9l\u00e9ment, il est impossible d'utiliser la variable pour modifier directement le contenu de la liste. Elle n'est alors pas du tout modifi\u00e9e au contraire du parcours par indice qui permet parfaitement de g\u00e9rer ce genre de cas. F. Listes par compr\u00e9hension Il existe une derni\u00e8re notion pouvant s'av\u00e9rer utile lors de la manipulation et notamment lors de la cr\u00e9ation de listes : les listes par compr\u00e9hension. Cr\u00e9er des listes par compr\u00e9hension emploie la boucle for et peut-\u00eatre aussi l'instruction if d'une mani\u00e8re inhabituelle. Pour maitriser les listes par compr\u00e9hension, il va vous falloir oublier la syntaxe habituelle des boucles ainsi que des conditions. Mais \u00e0 quoi servent-elles exactement ces listes par compr\u00e9hension ? Il s'agit d'un outil assez puissant qui permet de cr\u00e9er en une seule ligne (au lieu des habituelles trois \u00e0 quatre lignes) une liste avec un contenu qui suit une certaine logique. Assez parl\u00e9, voi\u00e7i un exemple o\u00f9 l'on emploie une liste par compr\u00e9hension afin de cr\u00e9er une liste contenant tous les nombres entiers de 0 \u00e0 99 : entiers = [ entier for entier in range ( 100 )] print ( entiers ) On peut \u00e9galement combiner cela avec des conditions. Par exemple, pour cr\u00e9er une liste contenant les nombres entiers qui sont \u00e0 la fois ni divisible par 2 et ni divisible par 3 de 0 \u00e0 99, on peut \u00e9crire : diviseurs = [ nombre for nombre in range ( 100 ) if nombre % 2 != 0 and nombre % 3 != 0 ] print ( diviseurs ) On peut \u00e9galement cr\u00e9er une liste par compr\u00e9hension \u00e0 partir d'une autre liste au lieu d'utiliser le range : resultats = [ 29 , 2876 , 18 , 27365 , 1762 , 67548930 , 2873649221 , 229 , 2737 , 205 , 27632 , 3764 , 17 ] filtre = [ nombre for nombre in resultats if nombre % 2 != 0 and nombre % 3 != 0 ] print ( filtre ) Les listes par compr\u00e9hension ne sont pas essentielles mais essayons tout de m\u00eame de retenir la syntaxe suivante : liste_comprehension = [ nouvelle_variable for nouvelle_variable in container if condition ] if condition \u00e9tant facultatif et container devant \u00eatre remplac\u00e9 par un range ou bien par un objet qui contient plusieurs \u00e9l\u00e9ments (comme une liste). 7 - Les boucles tant que A. La boucle while Nous avons vu comment cr\u00e9er une boucle qui r\u00e9p\u00e9te des instructions un nombre connu de fois. Mais comment faire dans le cas o\u00f9 on ne sait pas exactement combien de fois une instruction doit \u00eatre r\u00e9p\u00e9t\u00e9e ? C'est l'int\u00e9r\u00eat d'une boucle while . Sa syntaxe est la suivante : while condition : # bloc d'instructions \u00e0 r\u00e9p\u00e9ter Une boucle while r\u00e9p\u00e9te le bloc \u00e0 l'int\u00e9rieur d'elle tant que condition vaut True . Par exemple, nous pouvons diviser un nombre par 2 tant que le r\u00e9sultat obtenu est pairjusqu'\u00e0 finalement obtenir un nombre impair : nombre = 2048 nb_operations = 0 while nombre % 2 == 0 : nombre /= 2 nb_operations += 1 print ( \"Nombre impair final obtenu :\" , nombre ) print ( \"Nombre de divisions n\u00e9cessaires :\" , nb_operations ) B. While : \u00e0 faire et \u00e0 ne pas faire Attention cependant \u00e0 bien faire attention \u00e0 ce que votre while se termine . En effet, une boucle while peut r\u00e9p\u00e9ter des instructions \u00e0 l'infini. Prenons par exemple le cas suivant : nombre = 17 while nombre != 0 : print ( nombre ) nombre -= 2 Ce programme ne s'arr\u00eate jamais ! C'est \u00e0 l'utilisateur de l'arr\u00eater manuellement. En effet, la condition propos\u00e9 plus haut ne sera jamais fausse, car nombre sera toujours diff\u00e9rent de 0. nombre est r\u00e9duit de 2 \u00e0 chaque it\u00e9ration. Le nombres que l'on obtient i\u00e7i appartiennent en fait \u00e0 la formule \\(17 - 2 \\times x\\) . Or, \\(17 - 2x = 0\\) est impossible \u00e0 r\u00e9soudre en sachant que \\(x\\) est un nombre entier (puisque \\(x\\) repr\u00e9sente le nombre d'op\u00e9rations qu'il y a eu lieu). Il faut donc toujours veiller \u00e0 ce que notre boucle while se termine d'une mani\u00e8re ou d'une autre. C. Quand while peut remplacer une boucle for Avez-vous remarqu\u00e9 que : for indice in range ( 20 ): print ( \"it\u00e9ration\" , indice ) Signifie plus ou moins la m\u00eame chose que : indice = 0 while indice < 20 : print ( \"it\u00e9ration\" , indice ) indice += 1 Nous pouvons m\u00eame g\u00e9n\u00e9raliser que : for variable in range ( debut , fin , pas ): # instructions Equivaut presque \u00e0 : variable = debut while variable < fin : # instructions variable += pas Nous pouvons donc nous dire que la boucle for ne para\u00eet pas si indispensable finalement. Toutefois for est peut-\u00eatre plus facile \u00e0 \u00e9crire et \u00e0 g\u00e9rer qu'une boucle while , bien que while propose plus d'options et accorde plus de contr\u00f4le, nous ne rempla\u00e7erons pas une boucle for par une boucle while si une boucle for est adapt\u00e9e \u00e0 la situation. 8 - Chaines de caract\u00e8res A. Cr\u00e9ation et caract\u00e9ristiques Nous avions b\u00eatement recopi\u00e9 des mots entre guillemets \u00e0 l'int\u00e9rieur d'instructions print jusque-l\u00e0, mais il faut savoir que ces valeurs portent un nom : il s'agit de cha\u00eenes de caract\u00e8res. Nous avons d\u00e9j\u00e0 cr\u00e9\u00e9 des cha\u00eenes de caract\u00e8res plusieurs fois auparavant, il suffit de mettre entre guillemets une suite de caract\u00e8res : nom_utilisateur = \"Turing le roi du ring\" mot_de_passe = \"ENIGMA\" Les cha\u00eenes de caract\u00e8res sont similaires aux listes dans la mesure o\u00f9 il est possible d'acc\u00e9der \u00e0 un caract\u00e8re d'une cha\u00eene par un indice, et elles poss\u00e8dent tout comme les listes une longueur ce qui rend possible les parcours de chaines de caract\u00e8res : animal = \"elephant\" for i in range ( len ( animal )): print ( \"Le caract\u00e8re situ\u00e9 \u00e0 l'indice\" , i , \"est :\" , animal [ i ]) Grosse diff\u00e9rence avec les listes cependant, c'est que les caract\u00e8res \u00e0 l'int\u00e9rieur des cha\u00eenes de caract\u00e8res ne sont pas modifiables ! Elles sont dites immutables . Par cons\u00e9quent, effectuer l'op\u00e9ration chaine[indice] = nouveau_caractere est impossible : pays_liste = [ \"I\" , \"r\" , \"a\" , \"n\" ] pays_liste [ 3 ] = \"k\" # Possible pays_chaine = \"Iran\" pays_chaine [ 3 ] = \"k\" # Impossible : une erreur se produit B. Concat\u00e9nation et format f-string Cependant, comme pour les listes, il est possible de concat\u00e9ner deux cha\u00eenes de caract\u00e8res. L'op\u00e9ration * est \u00e9galement disponible : pr\u00e9nom = \"Margaret\" nom = \"Hamilton\" complet = pr\u00e9nom + \" \" + nom print ( complet ) musique = \"do\" musique += \" r\u00e9 mi fa so \" musique *= 5 print ( musique ) Mais supposons que notre chaine de caract\u00e8res ait besoin du contenu d'une variable. Il existe un format sp\u00e9cifique pour cela : le format f-string . Pour sp\u00e9cifier que votre cha\u00eene est un f-string , il suffit d'\u00e9crire un f avant d'ouvrir les guillemets. Puis d'entourer par des accolades {} les variables que vous souhaitez utiliser : annee = 1989 inventeur = \"Tim Berners-Lee\" invention = \"le World Wide Web\" phrase = f \"En { annee } , { inventeur } inventa { invention } .\" print ( phrase ) Et il est plus agr\u00e9able de lire et d'\u00e9crire : print ( f \"En { annee } , { inventeur } inventa { invention } .\" ) Plut\u00f4t que : print ( \"En\" , annee , inventeur , \"inventa\" , invention , \".\" ) Bien que les deux fassent strictement la m\u00eame chose. C. M\u00e9thodes associ\u00e9es aux chaines de caract\u00e8res Nous l'avons vu auparavant, il est possible d'obtenir la longueur d'une cha\u00eene gr\u00e2ce \u00e0 la fonction len . len(\"Abracadabra !\") renvoie 13 par exemple (les espaces sont consid\u00e9r\u00e9s comme des caract\u00e8res). Il est possible d'obtenir une chaine de caract\u00e8res compos\u00e9es uniquement de majuscules \u00e0 partir d'une cha\u00eene initiale gr\u00e2ce \u00e0 la m\u00e9thode chaine_initiale.upper() . Il est aussi possible d'obtenir une cha\u00eene compos\u00e9e uniquement de minuscules d'une fa\u00e7on similaire, avec la m\u00e9thode chaine_initiale.lower() : chaine_originale = \"ceTtE ChAine EST toUtE DErEGlEe ! IL fauT la RePaRer.\" chaine_majuscules = chaine_originale . upper () chaine_minuscules = chaine_originale . lower () print ( chaine_majuscules ) print ( chaine_minuscules ) Nous pouvons \u00e9galement obtenir une liste \u00e0 partir d'une chaine de caract\u00e8re gr\u00e2ce \u00e0 la m\u00e9thode chaine.split(separateur) . La liste renvoy\u00e9e sera une division de la chaine caract\u00e8re initiale selon un caract\u00e8re s\u00e9parateur separateur . Par exemple, si on souhaite obtenir une liste contenant chaque mot d'une chaine (sachant que les mots sont s\u00e9par\u00e9s des espaces), on peut utiliser un espace comme s\u00e9parateur et \u00e9crire : phrase = \"Alan Turing roi du ring a battu George Boole le maboul\" mots = phrase . split ( \" \" ) print ( mots ) Sinon, nous pouvons mentionner l'ensemble des m\u00e9thodes isdigit , isalpha , isalnum , isascii , isupper , islower qui renvoient True si chacun des caract\u00e8res suivent une r\u00e8gle particuli\u00e8re. Par exemple, chaine.isupper() renvoie True si chacun des caract\u00e8res sont des majuscules. Comme autre exemple, chaine.isdigit() renvoie True si chacun des caract\u00e8res sont des chiffres. chaines = [ \"0011429382\" , \"ALLO\" , \"pizza\" , \" \" , \"Coucou ! Moi, c'est Noah le cacato\u00e8s.\" ] for i in range ( len ( chaines )): if chaines [ i ] . isdigit (): print ( f \"' { chaines [ i ] } ' ne poss\u00e8de que des chiffres\" ) elif chaines [ i ] . isupper (): print ( f \"Tous les caract\u00e8res alphab\u00e9tiques de ' { chaines [ i ] } ' sont des majuscules\" ) elif chaines [ i ] . islower (): print ( f \"Tous les caract\u00e8res alphab\u00e9tiques de ' { chaines [ i ] } ' sont des minuscules\" ) elif chaines [ i ] . isspace (): print ( f \"' { chaines [ i ] } ' est une suite d'espaces\" ) else : print ( f \"' { chaines [ i ] } ' poss\u00e8de une diversit\u00e9 de caract\u00e8res importante\" ) Il existe d'autres m\u00e9thodes, mais elles sont mineures. De plus, elles sont assez simples \u00e0 recr\u00e9er. D. Convertir une valeur d'un type \u00e0 l'autre Il peut arriver qu'on souhaite convertir une chaine de caract\u00e8re en un entier, et m\u00eame parfois un entier en une cha\u00eene de caract\u00e8re. Pour cela, on utilise int(objet) pour convertir objet en un nombre entier, et str(objet) afin de convertir objet en une cha\u00eene de caract\u00e8re. chaine = \"45\" entier = 201 conversion_chaine = chaine + str(entier) conversion_entier = entier + int(chaine) print(conversion_chaine) print(conversion_entier) Warning Attention cependant \u00e0 ne pas convertir n'importe quoi ! Par exemple, int(\"girafe\") provoquera une erreur. 9 - Fonctions A. D\u00e9finition et cas d'usage Na\u00efvement, nous avons d\u00e9j\u00e0 utilis\u00e9 plusieurs fonctions telles que print ou len . Quand on veut utiliser une fonction, on \u00e9crit le nom de la fonction toujours suivi par des parenth\u00e8ses () . A l'int\u00e9rieur de ces m\u00eames parenth\u00e8ses, il peut y avoir ou non des arguments . Le nombre d'arguments d\u00e9pend de la fonction utilis\u00e9e. Par exemple, len prend un seul argument obligatoire, qui doit \u00eatre une liste, une cha\u00eene de caract\u00e8res ou tout objet pouvant contenir plusieurs valeurs. Alors que print prend un nombre ind\u00e9fini d'arguments (sachant que chacun des arguments sont s\u00e9par\u00e9s par des virgules). Mais qu'est-ce qu'une fonction exactement ? En programmation, on pourrait d\u00e9finir une fonction comme une suite d'\u00e9tapes qui permet de r\u00e9soudre un probl\u00e8me sp\u00e9cifique. L\u00e0 o\u00f9 le programme r\u00e9soud un probl\u00e8me global, les fonctions r\u00e9solvent chacune un probl\u00e8me mineur pr\u00e9cis. Mais c'est chacune de ces fonctions qui permettent de r\u00e9soudre le probl\u00e8me global ! Un bon programme informatique est en g\u00e9n\u00e9ral d\u00e9coup\u00e9 en plusieurs fonctions, en fait, on pourrait m\u00eame qualifier les fonctions comme des sous-programmes qui permettent de compl\u00e9ter et d'assister le programme principal. B. Ecrire une fonction et renvoyer un r\u00e9sultat Passons \u00e0 la pratique. Pour cr\u00e9er une nouvelle fonction, on utilise le mot-cl\u00e9 def en respectant la syntaxe suivante : def nom_fonction (): # instructions Par exemple, si on veut \u00e9crire une fonction qui augmente de 1 la valeur de chaque entier dans une liste : def augmente_1 (): for i in range ( len ( liste_entiers )): liste_entiers [ i ] += 1 liste_entiers = [ 1 , 2 , 3 , 4 , 5 ] print ( liste_entiers ) En ex\u00e9cutant le programme, on remarque que le bloc d\u00e9fini \u00e0 l'int\u00e9rieur de la fonction augmente_1() a \u00e9t\u00e9 omis. En effet, une fonction n'est pas ex\u00e9cut\u00e9e si elle n'est pas appel\u00e9e . On aurait pu mettre n'importe quoi dans la fonction et cela n'aurait rien chang\u00e9 comme par exemple : def augmente_1 (): coucou ; System . out . println ( \"Ce\u00e7i n'est pas du java\" ); liste_entiers = [ 1 , 2 , 3 , 4 , 5 ] print ( liste_entiers ) Pour appeler une fonction (c'est-\u00e0-dire ex\u00e9cuter les instructions \u00e0 l'int\u00e9rieur de la fonction), il suffit d'\u00e9crire le nom de la fonction suivie de parenth\u00e8ses () : def augmente_1 (): for i in range ( len ( liste_entiers )): liste_entiers [ i ] += 1 for _ in range ( 5 ): augmente_1 () print ( liste_entiers ) Evidemment, nous pouvons appeler et r\u00e9utiliser une fonction autant de fois que l'on veut, et c'est \u00e7a qui les rend pratiques ! Une fonction peut \u00e9galement renvoyer un r\u00e9sultat avec le mot-cl\u00e9 return . Par exemple, une fonction qui renvoie une cha\u00eene de caract\u00e8res sans voyelles \u00e0 partir d'une chaine contenue dans la variable chaine_normale : def sans_voyelles (): new_string = \"\" voyelles = \"AEOUIYaeouiy\" for i in range ( len ( chaine_normale )): if not chaine_normale [ i ] in voyelles : new_string += chaine_normale [ i ] return new_string chaine_normale = \"Python, un langage de programmation unique en son genre.\" chaine_speciale = sans_voyelles () print ( chaine_speciale ) Warning Quand une fonction renvoie un r\u00e9sultat, ce r\u00e9sultat devrait \u00eatre stock\u00e9 dans une variable. Il faudrait donc \u00e9crire nom_variable = nom_fonction() plut\u00f4t que simplement nom_fonction() lorsque la fonction renvoie une valeur. Notez \u00e9galement que return marque la fin d'une fonction. M\u00eame s'il reste des instructions apr\u00e8s le mot-cl\u00e9 return , elles sont ignor\u00e9es. Par exemple : def exemple (): if 5 < 10 : print ( \"La fonction va renvoyer True\" ) return True print ( \"Cette instruction a \u00e9t\u00e9 ex\u00e9cut\u00e9e\" ) return False test = exemple () print ( test ) C. Arguments Ecrire des fonctions telles que nous les avons \u00e9crites auparavant est une grave erreur cependant. En effet, nous avons utilis\u00e9 des variables \u00e0 l'ext\u00e9rieur de la fonction plut\u00f4t que d'utiliser des arguments dans la conception de nos fonctions. Le probl\u00e8me est que cela rend notre fonction peu flexible et peu adaptable. Les arguments s'\u00e9crivent \u00e0 l'int\u00e9rieur des parenth\u00e8ses lors de la cr\u00e9ation et de l'appel des fonctions. Ainsi pour am\u00e9liorer la fonction augmente_1() : def augmente_1 (): for i in range ( len ( liste_entiers )): liste_entiers [ i ] += 1 liste_entiers = [ 1 , 2 , 3 , 4 , 5 ] print ( liste_entiers ) On cr\u00e9era plut\u00f4t une fonction augmente(n, liste) qui prend en argument la liste qui doit \u00eatre modifi\u00e9e et un nombre n qui repr\u00e9sente l'augmentation de chaque nombre de la liste au lieu d'utiliser directement des valeurs constantes telles que 1 ou des variales externes \u00e0 la fonction comme liste_entiers : def augmente ( n , liste ): for i in range ( len ( liste )): liste [ i ] += n liste_entiers = [ 1 , 2 , 3 , 4 , 5 ] autre_liste = [ 28 , 19 , 1 , 92 ] encore_une = [ - 16 , - 18 , - 43 , - 67 ] augmente ( n = 1 , liste = liste_entiers ) augmente ( n = - 5 , liste = autre_liste ) augmente ( n = 20.5 , liste = encore_une ) print ( liste_entiers ) print ( autre_liste ) print ( encore_une ) Notons que l'\u00e9criture augmente(n = 1, liste = liste_entiers) peut \u00eatre simplifi\u00e9e par augmente(1, liste_entiers) lors de l'appel d'une fonction. Nous avons simplement utilis\u00e9 l'affectation afin de clarifier ce qui se passe (on ex\u00e9cute le bloc contenu dans augmente sachant que n prend comme valeur 1 et liste prend comme valeur liste_entiers , toujours dans le cas pr\u00e9c\u00e9dent). Warning Lors de l'appel d'une fonction, les arguments doivent \u00eatre ordonn\u00e9s dans l'ordre d\u00e9fini par la d\u00e9finition originale de la fonction associ\u00e9e. Par exemple, pour la fonction augmente(n, liste) , augmente(liste_entiers, 1) correspond \u00e0 augmente(n = liste_entiers, liste = 1) et augmente(1, liste_entiers) correspond \u00e0 augmente(n = 1, liste = liste_entiers) . Ainsi augmente(1, liste_entiers) \\(\\not ={}\\) augmente(liste_entiers, 1) . Cependant, si l'ensemble des arguments sont identifi\u00e9s par une affectation explicite nom_argument = valeur , alors l'ordre n'est plus important, ce qui signifie que augmente(n = 1, liste = liste_entiers) \\(=\\) augmente(liste = liste_entiers, n = 1) . Tip Arguments, valeurs par d\u00e9faut : nous pouvons donner une valeur initiale \u00e0 un argument lors de la d\u00e9finition de sa fonction. Par exemple : def deplacer(objet, distance=1): . I\u00e7i nous donnons une valeur par d\u00e9faut \u00e0 l'argument distance , c'est-\u00e0-dire que si l'on omet de donner une valeur \u00e0 distance lors de l'appel de la fonction deplacer , distance prendra automatiquement la valeur 1. Ainsi, deplacer(nuage) fera strictement la m\u00eame chose que deplacer(objet = nuage, distance = 1) dans ce contexte. Challenge Enonc\u00e9 Correction En utilisant des arguments, am\u00e9liorez la fonction sans_voyelles de sorte qu'elle puisse g\u00e9rer n'importe quelle chaine de caract\u00e8re et non pas uniquement chaine_normale . def sans_voyelles ( chaine_initiale ): new_string = \"\" voyelles = \"AEOUIYaeouiy\" for i in range ( len ( chaine_initiale )): if not chaine_initiale [ i ] in voyelles : new_string += chaine_initiale [ i ] return new_string exemple_1 = sans_voyelles ( \"abracadabra !) exemple_2 = sans_voyelles ( \"Les fonctions sont essentielles en programmation\" ) D. Fonctions : attention \u00e0 la port\u00e9e ! Tout ce qui a \u00e9t\u00e9 cr\u00e9\u00e9 \u00e0 l'int\u00e9rieur d'une fonction existe uniquement \u00e0 l'int\u00e9rieur de cette fonction. Il n'est plus accessible en dehors. Par cons\u00e9quent un code comme celui-\u00e7i est incorrect : def mystere ( n , ajout = 0 , retrait = 0 , coefficient = 1 , diviseur = 1 , puissance = 1 ): somme = n + ajout - retrait produit = somme * coefficient / diviseur final = produit ** puissance mystere ( 42 , retrait = 5 , puissance = 2 , coefficient = 3 ) print ( final ) I\u00e7i, le programme cherche \u00e0 afficher la valeur de final . Or, final est situ\u00e9 \u00e0 l'int\u00e9rieur de la fonction mystere et n'existe plus \u00e0 l'ext\u00e9rieur de celle-\u00e7i. Une erreur va ainsi se produire. Une solution possible \u00e0 ce probl\u00e8me serait de renvoyer final \u00e0 l'appel de la fonction : def mystere ( n , ajout = 0 , retrait = 0 , coefficient = 1 , diviseur = 1 , puissance = 1 ): somme = n + ajout - retrait produit = somme * coefficient / diviseur final = produit ** puissance return final solution = mystere ( 42 , retrait = 5 , puissance = 2 , coefficient = 3 ) print ( solution ) Similairement, il est impossible de modifier depuis l'int\u00e9rieur d'une fonction une variable qui existe \u00e0 l'ext\u00e9rieur de celle-ci. Ainsi, le programme suivant provoquera une erreur : def reinitialisation (): timer = 0 point_de_vies = 25 score = 0 timer = 14 point_de_vies = 18 score = 346 reinitialisation () N'oublions jamais que, en Python, le r\u00f4le d'une fonction n'est pas de modifier une variable existante. C'est assez important d'\u00eatre conscient de cela lorsqu'on d\u00e9bute en programmation (selon l'exp\u00e9rience du cr\u00e9ateur du site). 10 - Gestion de fichiers A. Ouvrir et lire le contenu d'un fichier Enfin, dernier aspect que nous aborderons pour ce chapitre : la gestion des fichiers avec Python. Python nous permet facilement d'ouvrir et de lire le contenu d'un fichier (sous forme de texte). Mais avant de donner une quelconque instruction Python, nous devons \u00eatre s\u00fbr de comprendre la notion d'arborescence des fichiers . Pour donner une d\u00e9finition simple, l'arborescence est la structure qui d\u00e9finit la position des fichiers dans un syst\u00e8me. Pour trouver un fichier dans une arborescence, nous devons sp\u00e9cifier son chemin. Par exemple C:\\Users\\VICTOR\\Documents\\Travail Nsi\\mkdoc_test\\docs\\C3-Python.md est le chemin permettant d'acc\u00e9der au fichier C3-Python.md . Il y a deux types de chemins. Premi\u00e8rement, le chemin absolu qui part de la racine (ou l'origine) de l'arborescence, comme le chemin vu plus t\u00f4t C:\\Users\\VICTOR\\Documents\\Travail Nsi\\mkdoc_test\\docs\\C3-Python.md dont la racine est i\u00e7i repr\u00e9sent\u00e9e par le C: . Deuxi\u00e8mement, le chemin relatif qui part du dossier actuellement ouvert. Par exemple, en supposant que nous travaillons sur le dossier mkdoc_test , le chemin relatif pour acc\u00e9der \u00e0 C3-Python.md devient alors docs\\C3-Python.md . Nous favoriserons les chemins relatifs au chemins absolus car ils sont plus faciles \u00e0 \u00e9crire. Par ailleurs, vous vous \u00eates peut-\u00eatre d\u00e9j\u00e0 demand\u00e9 l'int\u00e9r\u00eat d'ouvrir un r\u00e9pertoire \u00e0 partir de VS code comme montr\u00e9 \u00e0 la partie 2 de ce chapitre. La r\u00e9ponse est simple. Travailler dans un r\u00e9pertoire nous permet de travailler sur tout un ensemble de fichiers en m\u00eame temps ! A-retenir Lorsqu'on utilise VS code, tous les chemins relatifs auront pour point de d\u00e9part le dossier sur lequel vous travaillez Passons \u00e0 la programmation. Pour ouvrir et lire le contenu d'un fichier existant (par exemple un fichier que vous avez cr\u00e9\u00e9 nomm\u00e9 \"hello.txt\" dans lequel vous avez \u00e9crit ce que vous souhaitez), nous pouvons utiliser la fonction open de Python et la m\u00e9thode read associ\u00e9e aux fichiers : fichier = open ( \"hello.txt\" ) contenu_fichier = fichier . read () fichier . close () print ( contenu_fichier ) Pour obtenir une liste o\u00f9 chacune des lignes du fichier repr\u00e9sentent un \u00e9l\u00e9ment de la liste, on peut utiliser la m\u00e9thode fichier.readlines() : fichier = open ( \"hello.txt\" ) lignes_fichier = fichier . readlines () fichier . close () print ( lignes_fichier ) B. Fichiers : \u00e0 faire attention Ne jamais oublier l'instruction fichier.close() \u00e0 partir du moment o\u00f9 l'on a d\u00e9j\u00e0 lu le contenu du fichier. Quand on ouvre un fichier, il faut toujours finir par le fermer. Une alternative \u00e0 fichier.close() serait d'utiliser le mot-cl\u00e9 with : fichier = open ( \"hello.txt\" ) contenu_fichier = fichier . read () fichier . close () print ( contenu_fichier ) Signifie la m\u00eame chose que : with open ( \"hello.txt\" ) as fichier : contenu_fichier = fichier . read () print ( contenu_fichier ) Avez-vous \u00e9galement remarqu\u00e9 les \\n lorsque l'on utilise fichier.readlines() ? \\n est un caract\u00e8re sp\u00e9cial qui signifie un saut de ligne. Ils vont en g\u00e9n\u00e9ral \u00eatre g\u00eanant pour votre programme. Challenge Enonc\u00e9 Correction Essayer de cr\u00e9er une fonction lire_lignes(fichier) alternative \u00e0 la m\u00e9thode readlines() , qui prend en argument fichier : le chemin du fichier que vous souhaitez lire. lire_lignes(fichier) doit renvoyer une liste contenant les diff\u00e9rentes lignes du fichier pass\u00e9 en argument, mais sans les caract\u00e8res \\n def lire_lignes ( fichier ): liste_finale = [ \"\" ] with open ( fichier ) as fic : contenu = fic . read () for char in contenu : if char == \" \\n \" : liste_finale . append ( \"\" ) else : liste_finale [ - 1 ] += char return liste_finale On commence par ouvrir et lire le contenu du fichier en question. On parcourt ensuite le contenu et si le caract\u00e8re est un saut de ligne, on ajoute simplement une chaine de caract\u00e8res vide symbolisant la ligne suivante. Comme nous ajoutons toujours les caract\u00e8res s\u00e9l\u00e9ctionn\u00e9s \u00e0 la derni\u00e8re chaine ajout\u00e9e ( liste_finale[-1] += char ), le contenu du fichier est dans le bon ordre ! Warning Quand on utilise l'instruction read ou readlines , les valeurs renvoy\u00e9es seront toujours des cha\u00eenes de caract\u00e8res. C'est \u00e0 vous de convertir les informations obtenues si n\u00e9cessaire. C. Modifier un fichier et cr\u00e9er un nouveau fichier Il est possible de modifier le contenu d'un fichier gr\u00e2ce au langage Python. Pour cela, il faut ouvrir un fichier en mode \u00e9criture et utiliser la m\u00e9thode fichier.write() : with open ( \"hello.txt\" , \"w\" ) as fic : fic . write ( \"Coucou !\" ) Le \"w\" dans la fonction open signifie que l'on ouvre notre fichier en mode \u00e9criture. D\u00e9sormais, en ouvrant le fichier hello.txt , vous remarquerez qu'il ne contient qu'une seule chose : \"Coucou !\". Warning L'instruction write \u00e9crase le contenu pr\u00e9c\u00e9dent du fichier. Elle efface int\u00e9gralement le contenu du fichier avant d'\u00e9crire dedans. De plus, il est impossible de lire un fichier qui a \u00e9t\u00e9 ouvert en mode \u00e9criture. Remarquons cependant que write cr\u00e9e un nouveau fichier si le fichier n'existe pas d\u00e9j\u00e0, ce qui peut s'av\u00e9rer tr\u00e8s utile. Conclusion Cette page vous a donc servi de rappel ou d'initiation aux principaux concepts du langage Python. Cependant, le meilleur moyen d'apprendre la programmation, c'est en programmant. C'est par la pratique qu'on apprend le mieux la programmation ! Il est donc fortement conseill\u00e9 de se cr\u00e9er un compte sur le site France IOI et de s'entra\u00eener \u00e0 la programmation ainsi qu'\u00e0 la r\u00e9solution de probl\u00e8mes sur ce dernier. Glossaire programme informatique : suite d'instructions logiques destin\u00e9es \u00e0 \u00eatre ex\u00e9cut\u00e9es par un ordinateur. langage de programmation : interm\u00e9diaire entre l'humain et l'ordinateur. Permet la r\u00e9daction de codes sources. code source : l'ensemble des programmes r\u00e9dig\u00e9s et faits pour \u00eatre lus par un \u00eatre humain n\u00e9cessaire \u00e0 la production d'un ex\u00e9cutable en langage machine. ex\u00e9cutable : suite d'instructions \u00e9crites en langage machine pouvant \u00eatre directement ex\u00e9cut\u00e9es par un ordinateur. langage machine : langage binaire (des 0 et des 1) compr\u00e9hensible par l'ordinateur. compilation : proc\u00e9d\u00e9 par lequel un code soure est traduit en une seule fois et en son int\u00e9gralit\u00e9 en langage machine afin de g\u00e9n\u00e9rer un ex\u00e9cutable. interpr\u00e9tation : proc\u00e9d\u00e9 par lequel un code soure est traduit ligne apr\u00e8s ligne en langage machine afin de g\u00e9n\u00e9rer un ex\u00e9cutable. d\u00e9boguer : trouver et corriger les anomalies d'un programme. int : diminutif de integer, qui signifie nombre entier en anglais. float : diminutif de floating point number, qui signifie nombre flottant anglais et qui relate aux nombres \u00e0 virgule. str : diminutif de string, qui signifie cha\u00eene de caract\u00e8res en anglais. Une cha\u00eene de caract\u00e8res est simplement un regroupement de caract\u00e8res, g\u00e9n\u00e9ralement d\u00e9limit\u00e9 par des guillemets en programmation. caract\u00e8re : un caract\u00e8re peut \u00eatre une lettre alphab\u00e9tique miniscule ou majuscule, un chiffre, une virgule, un point, un emoji, etc. C'est une notion plus ou moins abstraite mais pour donner une d\u00e9finition simple, nous dirons qu'un caract\u00e8re constitue l'ensemble des \u00e9l\u00e9ments qu'un ordinateur peut \u00e9crire ou afficher (hors images et couleurs) selon une police et un encodage. encodage : \u00e9tant donn\u00e9 que l'ordinateur ne peut manipuler que des valeurs num\u00e9riques, les caract\u00e8res doivent \u00eatre associ\u00e9s \u00e0 un nombre afin d'\u00eatre manipul\u00e9s par l'ordinateur. C'est le r\u00f4le de l'encodage de caract\u00e8res. Celui-ci permet de repr\u00e9senter individuellement chaque caract\u00e8re parmi une multitude de caract\u00e8res par un nombre. Aujourd'hui, l'encodage de caract\u00e8res le plus r\u00e9pandu est UTF-8. codage RGB : similairement \u00e0 l'encodage de caract\u00e8res, l'ordinateur a besoin de valeurs num\u00e9riques afin de repr\u00e9senter des couleurs. C'est justement le principe du codage RGB (Red Green Blue). Son fonctionnement est simple. Il utilise un triplet de valeurs allant de 0 \u00e0 255 afin de d\u00e9crire une couleur. Chaque valeur repr\u00e9sente dans l'ordre : l'intensit\u00e9 du rouge, l'intensit\u00e9 du vert, et l'intensit\u00e9 du bleu (d'o\u00f9 le nom Rouge Vert Bleu). bit : un seul chiffre binaire (0 ou 1) qui d\u00e9crit une valeur. octet : 8 bits qui d\u00e9crivent une valeur. variable : un identifiant auquel on associe une valeur, les variables sont utilis\u00e9es en informatique pour m\u00e9moriser et suivre l'\u00e9volution d'une information. fonction : similairement aux fonctions math\u00e9matiques, les fonctions peuvent prendre un ou plusieurs arguments. Il s'agit de la d\u00e9finition d'une proc\u00e9dure qui peut ou non renvoyer un r\u00e9sultat. L'int\u00e9r\u00eat de stocker une suite d'op\u00e9rations dans une d\u00e9finition de fonction est de pouvoir la r\u00e9utiliser facilement sans avoir \u00e0 recopier les m\u00eame op\u00e9rations encore et encore. argument : \u00e9galement appel\u00e9 param\u00e8tre, valeur que l'on \u00e9crit g\u00e9n\u00e9ralement entre les parenth\u00e8ses qui suivent une fonction et qui influence le d\u00e9roul\u00e9 d'une fonction et le r\u00e9sultat qu'elle renvoie. module : fichier contenant des fonctions, variables et objets non disponibles initialement pour un langage de programmation. librairie : ensemble de modules. bloc de code : instructions group\u00e9es appartenant \u00e0 une instruction m\u00e8re (une boucle, une fonction, une condition, etc) indentation : syst\u00e8me de d\u00e9limitation de blocs de codes qui utilise les espaces et particuli\u00e8rement la tabulation. condition : valeur bool\u00e9ene que l'ordinateur exploite pour prendre une d\u00e9cision. bool\u00e9en : une valeur bool\u00e9ene est une valeur ne pouvant prendre que deux valeurs (Vrai ou Faux). Le mot vient du math\u00e9maticien George Boole, inventeur de l'alg\u00e8bre du m\u00eame nom. concat\u00e9nation : op\u00e9ration qui rassemble deux valeurs pour les faire fusionner en une valeur de taille plus importante. Exemples : \"conca\" || \"tenation\" = concatenation; 29 || 42 = 2942.","title":"C2 - Programmer en Python"},{"location":"C2-Python/#c2-programmer-en-python","text":"","title":"C2 - Programmer en Python"},{"location":"C2-Python/#introduction","text":"Afin de cr\u00e9er des jeux vid\u00e9os, il faut savoir programmer. Ce chapitre vous initiera \u00e0 un langage de programmation facile \u00e0 prendre en main : Python. Quote La programmation n'est pas simplement la r\u00e9daction d'instructions pour un ordinateur. Il s'agit d'une fa\u00e7on de penser. Le bon programmeur pense comme un ordinateur. Il sait se mettre \u00e0 la place de l'ordinateur et peut simuler l'ex\u00e9cution d'un programme \u00e9tape par \u00e9tape rien que dans sa t\u00eate. Cependant, si vous \u00eates d\u00e9j\u00e0 \u00e0 l'aise avec le langage Python, vous pouvez directement passer au prochain chapitre. Cette page vous donnera quelques bases fondamentales pour programmer en Python. Mais il faut tout de m\u00eame savoir que la meilleure mani\u00e8re d'apprendre \u00e0 programmer, c'est la pratique. Nous vous invitons donc \u00e0 cr\u00e9er un compte et \u00e0 vous entrainer \u00e0 la programmation sur le site France IOI avant m\u00eame de commencer \u00e0 lire \u00e0 cette page. La d\u00e9finition des mots en gras pourra \u00eatre retrouv\u00e9e dans le glossaire en bas de page.","title":"Introduction"},{"location":"C2-Python/#1-caracteristiques-du-langage","text":"","title":"1 - Caract\u00e9ristiques du langage"},{"location":"C2-Python/#a-langage-interprete","text":"Python est un langage interpr\u00e9t\u00e9 , c'est-\u00e0-dire que votre code est traduit ligne apr\u00e8s ligne en langage machine (une suite de 0 et de 1 que l'ordinateur peut comprendre). En opposition \u00e0 la compilation , o\u00f9 tout votre code est traduit en une seule fois en langage machine. Le probl\u00e8me qui en \u00e9merge est le fait que les langages de programmation interpr\u00e9t\u00e9s sont plus lents que leurs confr\u00e8res compil\u00e9s. Toutefois, ils sont plus faciles \u00e0 d\u00e9boguer (trouver les bugs et les corriger) que les langages compil\u00e9s.","title":"A. Langage interpr\u00e9t\u00e9"},{"location":"C2-Python/#b-riche-en-modules-et-librairies","text":"Python poss\u00e8de de nombreuses librairies et modules , qui sont des ensembles d'outils non disponibles initialement (un peu comme des extensions), comme la librairie Pygame qui nous permettra de cr\u00e9er des jeux vid\u00e9os.","title":"B. Riche en modules et librairies"},{"location":"C2-Python/#c-utilise-lindentation","text":"Ce qui d\u00e9marque Python de la plupart des autres langages, c'est qu'il exploite l'indentation pour d\u00e9limiter les diff\u00e9rents blocs de code . Alors que d'autres langages comme le C ou le Java utilise des accolades {}, Python utilise des suites d'espaces g\u00e9n\u00e9r\u00e9s par la touche de tabulation, ce qui le rend plus lisible pour un \u00eatre humain. Example Java Python public static void main ( String [] args ) { if ( 1 + 1 == 2 ) { System . out . println ( \"1 + 1 font 2\" ); } else { System . out . println ( \"Votre ordinateur est d\u00e9faillant.\" ); } } def main (): if 1 + 1 == 2 : print ( \"1 + 1 font 2\" ) else : print ( \"Votre ordinateur est d\u00e9faillant.\" ) Dans cet exemple, on remarque une accumulation d'accolades pour le langage Java afin de savoir \u00e0 quel bloc il appartient. Ces accolades sont remplac\u00e9es par des tabulations en Python. Vous remarquez sans doute que nous avons pourtant \u00e9galement utilis\u00e9 l'indentation pour Java en plus des accolades. Ces indentations n'ont en fait aucun effet sur le code au contraire du langage Python, l'utilisation d'espaces a simplement pour but rendre le code plus lisible.","title":"C. Utilise l'indentation"},{"location":"C2-Python/#d-typage-dynamique","text":"Vous n'\u00eates pas contrait de d\u00e9clarer le type des variables (des sorte de bo\u00eetes qui servent \u00e0 m\u00e9moriser une valeur) que vous cr\u00e9ez, au contraire encore une fois du C et du Java. Car les variables peuvent changer de type. Prenons le code suivant qui affiche le contenu d'une variable nomm\u00e9e a : Example Java Python int a = 42 ; a = \"La r\u00e9ponse \u00e0 la question ultime.\" ; System . out . println ( a ); Sortie : error incompatible types String cannot be converted to int a = 42 a = \"La r\u00e9ponse \u00e0 la question ultime.\" print ( a ) Sortie : La r\u00e9ponse \u00e0 la question ultime. I\u00e7i, on cr\u00e9e une variable a et on lui affecte la valeur 42 qui est une valeur num\u00e9rique enti\u00e8re (type int ). Puis on lui affecte une nouvelle valeur qui est cette fois-\u00e7i une chaine de caract\u00e8res (type string ). Python n'a aucun probl\u00e8me pour g\u00e9rer ce cas de figure. En revanche, Java en est incapable, ce qui provoque ainsi une erreur.","title":"D. Typage dynamique"},{"location":"C2-Python/#2-installation","text":"","title":"2 - Installation"},{"location":"C2-Python/#a-installer-python","text":"Pour pouvoir d\u00e9velopper en Python, il va vous falloir un interpr\u00e9teur Python. Pour cela, direction le site officiel du langage Python puis t\u00e9l\u00e9chargez la version la plus r\u00e9cente.","title":"A. Installer Python"},{"location":"C2-Python/#b-installer-visual-studio-code","text":"Vous pouvez programmer depuis votre bloc-notes mais il est plus efficace de programmer depuis un IDE (environnement de d\u00e9veloppement). Il en existe plusieurs mais nous choisirons VS code, que vous pourrez retrouver et t\u00e9l\u00e9charger sur ce site .","title":"B. Installer Visual Studio code"},{"location":"C2-Python/#c-installer-lextension-python","text":"Une fois que vous aurez install\u00e9 et lanc\u00e9 VS code, il est fortement recommand\u00e9 d'installer l'extension Python. Vous pourrez retrouver et t\u00e9l\u00e9chargez diff\u00e9rentes extensions dans le barre de navigation gauche de VS code (les quatres petits cubes). Cliquez sur le bouton \"installer\" bleu et cela devrait d\u00e9buter l'installation de l'extension.","title":"C. Installer l'extension Python"},{"location":"C2-Python/#d-creer-un-nouveau-projet","text":"Lorsque vous programmerez, vous travaillerez g\u00e9n\u00e9ralement dans un r\u00e9pertoire (ou dossier). Pour cr\u00e9er un nouveau projet, cr\u00e9ez simplement un nouveau r\u00e9pertoire puis ouvrez-le \u00e0 partir de VS code. Afin d'ouvrir un r\u00e9pertoire, il faut cliquer sur l'onglet \"fichier\" en haut \u00e0 gauche, puis cliquez sur l'option \"ouvrir un r\u00e9pertoire\" dans le menu d\u00e9roulant (il s'agit de la 5e option depuis le haut). Vous pourrez ensuite cr\u00e9er des fichiers code source Python (.py) dans lesquels vous \u00e9crirez votre code \u00e0 partir de l'\u00e9diteur, et ce tr\u00e8s facilement. Il suffit d'aller dans le menu \u00e0 gauche et cliquer sur l'ic\u00f4ne de fichier avec un +. Nommez votre fichier et n'oubliez pas d'ajouter l'extension .py \u00e0 la fin du nom. Comme montr\u00e9 \u00e7i-dessous : Et cela cr\u00e9e un fichier code source Python dans le r\u00e9pertoire que vous avez ouvert ! Maintenant que nous avons un fichier dans lequel coder, nous pouvons enfin commencer \u00e0 programmer.","title":"D. Cr\u00e9er un nouveau projet"},{"location":"C2-Python/#3-afficher-du-texte-variables-et-execution","text":"","title":"3 - Afficher du texte, variables et ex\u00e9cution"},{"location":"C2-Python/#a-hello-world","text":"Tr\u00e8s souvent, la premi\u00e8re chose qu'on veut faire lorsqu'on apprend un nouveau langage de programmation, c'est d'afficher le texte \"Hello world!\". En Python, on affiche du texte gr\u00e2ce \u00e0 l'instruction print(valeur) en rempla\u00e7ant valeur par ce que vous souhaitez afficher. Ainsi pour afficher \"Hello world!\", on \u00e9crira : print ( \"Hello world!\" )","title":"A. Hello world!"},{"location":"C2-Python/#b-executer-son-programme","text":"Une fois cette instruction \u00e9crite dans votre fichier .py, il ne reste plus qu'\u00e0 l'ex\u00e9cuter. Sur VS code, un moyen d'ex\u00e9cuter le fichier actuellement \u00e9dit\u00e9 consiste \u00e0 cliquer sur l'onglet \"Ex\u00e9cuter\" situ\u00e9 au m\u00eame niveau que l'onglet \"Fichier\" puis de choisir l'option sans d\u00e9bogage. L'ordinateur ex\u00e9cutera ainsi tout ce que vous lui avez ordonn\u00e9 de faire dans votre programme. Note Notez que le texte Hello world! est entour\u00e9 par des guillemets. Les guillemets servent \u00e0 diff\u00e9rencier les chaines de caract\u00e8res des noms de variables. Nous explorerons la notion de chaine de caract\u00e8re vers la fin du chapitre.","title":"B. Ex\u00e9cuter son programme"},{"location":"C2-Python/#c-les-variables","text":"Mais qu'est-ce qu'une variable ? Une variable est, pour donner une d\u00e9finition simple, une bo\u00eete nomm\u00e9e par un identifiant et qui contient une valeur. Par exemple : impair = 5 I\u00e7i nous avons cr\u00e9\u00e9 une variable que nous avons nomm\u00e9 impair et \u00e0 laquelle nous avons affect\u00e9 le nombre 5. Attention, le signe = en Python ne symbolise pas une \u00e9galit\u00e9 math\u00e9matique mais une affectation . Nous verrons comment tester une \u00e9galit\u00e9 dans la 5e partie de ce chapitre. Par cons\u00e9quent, le contenu d'une variable peut \u00eatre modifi\u00e9 (d'o\u00f9 le nom 'variable'). De plus, nous pouvons utiliser son nom (alias son identifiant) pour acc\u00e9der \u00e0 la valeur qu'elle contient, comme nous pouvons le constater dans l'exemple \u00e7i-dessous : impair = 5 impair = impair - 2 print ( impair ) Warning Attention aux noms que vous donnez \u00e0 vos variables ! Les espaces, parenth\u00e8ses, guillemets, les op\u00e9rateurs + - = % / , et la plupart des caract\u00e8res qui ne sont pas alphanum\u00e9riques sont interdits. Vous pouvez mettre des chiffres dans le nom de votre variable tant qu'il ne s'agit pas du caract\u00e8re situ\u00e9 au tout d\u00e9but du nom. Tip Il est recommand\u00e9 de donner des noms significatifs \u00e0 vos variables, c'est-\u00e0-dire des noms qui illustrent le contenu de la variable. Par exemple une variable qui contient toujours un nombre impair devrait \u00eatre nomm\u00e9e impair , comme dans l'exemple. Si le nom de votre variable s'\u00e9crit sur plusieurs mots, vous pouvez utiliser des underscore _ afin de remplacer les espaces ( snake_case ). Vous pouvez \u00e9galement employer l'\u00e9criture camelCase .","title":"C. Les variables"},{"location":"C2-Python/#4-faire-des-calculs","text":"","title":"4 - Faire des calculs"},{"location":"C2-Python/#a-addition-et-soustraction","text":"Dans le dernier programme, nous avons utilis\u00e9 la soustraction avec impair - 2 . En Python, comme dans la quasi-totalit\u00e9 des langages de programmation, il est possible d'effectuer des op\u00e9rations math\u00e9matiques. Nous pouvons par exemple additionner et soustraire des valeurs gr\u00e2ce aux op\u00e9rateurs + et - : total = 50 vaches = 11 poules = 23 cochons = total - vaches - poules mammiferes = vaches + cochons print ( mammiferes ) Le r\u00e9sultat obtenu est \\(11 + 50 - 11 - 23 = 27\\) .","title":"A. Addition et soustraction"},{"location":"C2-Python/#b-multiplication-et-division","text":"La multiplication s'effectue avec un ast\u00e9risque * tandis que la division classique s'effectue avec un slash / . n = 10 somme_entiers = ( n + 1 ) * n / 2 print ( somme_entiers ) Maths somme_entiers abrite en fait la formule permettant de calculer les n premiers entiers positifs cons\u00e9cutifs : \\(\\frac{n}{2}(n + 1)\\) . Par exemple pour calculer \\(n = 6\\) , soit \\(1 + 2 + 3 + 4 + 5 + 6\\) . Il suffit d'appliquer la formule : \\(S = \\frac{6}{2}(6 + 1)\\) . Par cons\u00e9quent, il ne reste plus qu'\u00e0 simplifier le calcul : \\(S = 3 \\times 7 = 21\\) . Et voil\u00e0 ! Le tour est jou\u00e9. Plus facile que d'additionner \\(1 + 2 + 3 + 4 + 5 + 6\\) , non ?","title":"B. Multiplication et division"},{"location":"C2-Python/#c-division-euclidienne-et-reste","text":"Vous vous rappelez peut-\u00eatre de l'ancienne division que vous effectuiez en primaire. Celle qui permet d'obtenir un quotient et un reste. Il s'agit de la division euclidienne. Par exemple, \\(37 \\div 8 = 8 \\times 4 + 5\\) . I\u00e7i, le quotient de la division \\(37 \\div 8\\) est 4, tandis que le reste obtenu est 5. Pour obtenir le quotient d'une division euclidienne en Python, il suffit d'\u00e9crire un double slash // entre les deux nombres que l'on souhaite diviser : position = 37 // 8 print ( position ) Quant au reste d'une division euclidienne, il suffit de remplacer le double slash // par un % . pas = 37 % 8","title":"C. Division euclidienne et reste"},{"location":"C2-Python/#d-puissances-racines-carrees-et-modules","text":"Pour \u00e9lever un nombre \u00e0 une puissance en Python, il suffit d'\u00e9crire nombre ** puissance en remplacant nombre par le nombre que vous souhaitez utiliser et puissance par la puissance \u00e0 laquelle vous souhaitez l'\u00e9lever. On utilise donc le double ast\u00e9risque ** pour \u00e9lever \u00e0 une puissance : a = 4 b = 3 res = ( a + b ) ** 3 print ( res ) Remarquons l'utilisation des parenth\u00e8ses (a + b) , en informatique tout comme en math\u00e9matiques, il existe une priorit\u00e9 op\u00e9ratoire . L'utilisation des parenth\u00e8ses permet de donner une priorit\u00e9 \u00e0 un groupe d'op\u00e9rations. Sachant que sont calcul\u00e9s dans l'ordre : puissances / racines => multiplication / division => addition / soustraction Pour pouvoir calculer des racines, la m\u00e9thode sera l\u00e9g\u00e8rement diff\u00e9rente. Nous aurons besoin d'une fonction appartenant \u00e0 un module pr\u00e9-install\u00e9 : le module math . Pour pouvoir utiliser le contenu d'un module, il existe diff\u00e9rentes techniques. La premi\u00e8re, qui est la plus recommand\u00e9e \u00e0 utiliser, consiste \u00e0 importer le module et mentionner le nom du module chaque fois qu'on souhaite acc\u00e9der \u00e0 un outil appartenant au module : import math nombre_pi = math . pi print ( nombre_pi ) Dans l'exemple \u00e7i-dessus, nous avons import\u00e9 le module gr\u00e2ce \u00e0 l'instruction import math . Puis nous avons acc\u00e9d\u00e9 \u00e0 la valeur \\(\\pi\\) \u00e0 partir du module math avec l'instruction math.pi . La syntaxe pour utiliser un objet appartenant \u00e0 un module est donc nom_module.nom_objet . Le deuxi\u00e8me moyen d'acc\u00e9der au contenu d'un module est avec le mot-cl\u00e9 from . Celui-\u00e7i permet d'acc\u00e9der directement \u00e0 une ou plusieurs ressources du module sans avoir \u00e0 constamment sp\u00e9cifier le nom du module : from math import sqrt racine_16 = sqrt ( 16 ) print ( racine_16 ) Nous venons d'ailleurs tout juste de montrer comment calculer la racine carr\u00e9e d'un nombre en Python. La fonction sqrt(nombre) en rempla\u00e7ant nombre par le nombre auquel vous souhaitez calculer la racine carr\u00e9e. Info Il est conventionnel d'\u00e9crire les instructions import au tout d\u00e9but de votre programme. N'importez pas des modules en plein milieu de vos programmes ! Nous pouvons \u00e9galement importer l'int\u00e9gralit\u00e9 du contenu du module en une seule fois gr\u00e2ce au mot-cl\u00e9 from et le caract\u00e8re joker * : from math import * racine_pi = sqrt ( pi ) print ( racine_pi ) Nous pouvons utiliser sans probl\u00e8me la fonction sqrt et la valeur pi dans ce dernier exemple. Cependant cette m\u00e9thode n'est pas recommand\u00e9e car nous importons tout le contenu du module sans savoir pr\u00e9cis\u00e9ment ce que l'on importe. Warning Importer l'int\u00e9gralit\u00e9 du contenu d'un module peut provoquer des ambigu\u00eft\u00e9s . C'est-\u00e0-dire que deux fonctions ou deux variables qui ont deux r\u00f4les diff\u00e9rents risquent de porter le m\u00eame nom. Par exemple, si vous d\u00e9cidez de cr\u00e9er une variable pi apr\u00e8s avoir \u00e9crit l'instruction from math import * , alors vous perdrez la valeur initiale de pi import\u00e9e du module math.","title":"D. Puissances, racines carr\u00e9es et modules"},{"location":"C2-Python/#e-nombres-a-virgules","text":"En affichant la valeur de math.pi , vous avez peut-\u00eatre remarqu\u00e9 le . \u00e0 la suite du 3. Lorsqu'on \u00e9crit des nombres en Python, le . est l'\u00e9quivalent d'une virgule. Ainsi, \\(2,5\\) s'\u00e9crit 2.5 en Python. Les nombres \u00e0 virgules sont appel\u00e9s float , nombres flottants en fran\u00e7ais. Bug Il n'est pas efficace de tester des \u00e9galit\u00e9s (\u00e9galit\u00e9s que l'on \u00e9tudiera dans la partie suivante) quand on y inclut des nombres flottants. En essayant de calculer 0.1 + 0.2 et sqrt(2) * sqrt(2) , vous remarquerez que Python peut fournir des r\u00e9sultats impr\u00e9visibles quand il travaille avec des nombres \u00e0 virgule.","title":"E. Nombres \u00e0 virgules"},{"location":"C2-Python/#5-valeurs-booleenes-comparaisons-et-prises-de-decisions","text":"","title":"5 - Valeurs bool\u00e9enes, comparaisons et prises de d\u00e9cisions"},{"location":"C2-Python/#a-les-valeurs-booleennes","text":"En plus des nombres, il existe un autre type de valeur en informatique : les valeurs bool\u00e9ennes. Il s'agit d'un type ne pouvant prendre que deux valeurs diff\u00e9rentes, True ou False . Elles sont notamment utiles pour la prise de d\u00e9cision de l'ordinateur. Pour donner une valeur bool\u00e9enne \u00e0 une variable, c'est tr\u00e8s simple : toujours_vrai = True toujours_faux = False Nous pouvons m\u00eame effectuer des op\u00e9rations sur les valeurs bool\u00e9ennes. Le not permet d'inverser la valeur d'un bool\u00e9en. not True devient False et not False devient True . a = True b = False print ( not a ) print ( not b ) Nous pouvons \u00e9galement utiliser l'op\u00e9ration or qui prend deux valeurs bool\u00e9ennes et a pour r\u00e9sultat True si au moins l'une des deux valeurs vaut True . a = True b = False c = b or a d = c or a e = False or b print ( a , b , c , d , e ) c vaut True car a est vrai. d vaut True car c est vrai. e vaut False car ni False ni b ne sont vrais. La derni\u00e8re op\u00e9ration que nous pouvons utiliser est and . Comme or , and prend deux valeurs bool\u00e9ennes mais a pour r\u00e9sultat True uniquement si ces deux valeurs valent True . a = True or False b = False and not True c = a and True d = c and b e = c and d or b print ( a , b , c , d , e )","title":"A. Les valeurs bool\u00e9ennes"},{"location":"C2-Python/#b-conditions-if","text":"En Python, tout comme dans la plupart des langages de programmation, certaines instructions doivent pouvoir \u00eatre ex\u00e9cut\u00e9es sous une certaine condition . C'est le r\u00f4le de l'instruction if . toujours_vrai = True toujours_faux = False if toujours_vrai : print ( \"toujours_vrai est vrai\" ) if toujours_faux : print ( \"toujours_faux est vrai\" ) En ex\u00e9cutant le code \u00e7i-dessus, l'ordinateur n'affiche que \"toujours_vrai est vrai\". Car un bloc d'instructions appartennant \u00e0 un if n'est pris en compte que si la valeur bool\u00e9ene qui suit son if vaut True . La syntaxe pour \u00e9crire une condition if est donc : if condition : #bloc de code Attention cependant \u00e0 ne pas oublier les : \u00e0 la fin de l'instruction if ! Rappel Rappelons que Python utilise l'indentation pour d\u00e9limiter les blocs de code. Ainsi, pour marquer la fin et sortir d'un bloc de code, il suffit d'effacer la tabulation. Au contraire, pour ajouter un nouveau bloc (\u00e0 cause d'un if , d'un for , d'un while ou encore d'un def ), il suffit d'ajouter une tabulation. Nous pouvons \u00e9videmment combiner la condition avec les op\u00e9rations que nous avons \u00e9tudi\u00e9 \u00e0 la pr\u00e9c\u00e9dente partie. Par exemple : a = True b = True c = False if a or c : print ( \"Au moins 'a' ou 'c' vaut True\" ) if a and b : print ( \"'a' et 'b' valent tous les deux True\" ) if not b and c : print ( \"L'inverse de 'b' et 'c' valent tous les deux True\" )","title":"B. Conditions if"},{"location":"C2-Python/#c-operations-de-comparaison","text":"Il est possible de comparer deux valeurs afin d'obtenir un bool\u00e9en. Il existe six op\u00e9rations de comparaisons en Python ( > , < , >= , <= , == , != ). Avec == qui teste une \u00e9galit\u00e9 entre deux valeurs, et != qui teste une in\u00e9galit\u00e9 entre deux valeurs. Il est possible de comparer deux valeurs num\u00e9riques. Par exemple : strictement_superieur = 7 > 5 superieur_ou_egal = 3 >= 3 strictement_inferieur = 10 < 4 * 2 inferieur_ou_egal = - 15 <= 12 - 10 egal = 2 + 2 == 22 pas_egal = 0 != 1 print ( strictement_superieur ) print ( superieur_ou_egal ) print ( strictement_inferieur ) print ( inferieur_ou_egal ) print ( egal ) print ( pas_egal ) \\(7 > 5\\) est vrai donc on obtient True . \\(3 >= 3\\) est vrai donc on obtient aussi True . Cependant, \\(10 < 8\\) est faux donc on obtient False . \\(-15 <= 2\\) est vrai donc on obtient True . \\(4 = 22\\) est faux donc on obtient False . Enfin, 0 est en effet pas \u00e9gal \u00e0 1 donc on obtient True .","title":"C. Op\u00e9rations de comparaison"},{"location":"C2-Python/#d-linstruction-else-et-elif","text":"Supposons le cas suivant. Si nous sommes la matin, l'ordinateur devra afficher Bonjour . Si nous ne sommes pas le matin, l'ordinateur devra afficher Bonsoir . Pour faire cela, on pourrait utiliser l'op\u00e9ration not comme \u00e7i-dessous : matin = True if matin : print ( \"Bonjour\" ) if not matin : print ( \"Bonsoir\" ) Mais cela est r\u00e9p\u00e9titif ! if not matin est ex\u00e9cut\u00e9 si if matin n'est pas ex\u00e9cut\u00e9. En Python on peut remplacer cela avec une instruction else (signifiant 'sinon') \u00e0 la suite d'une instruction if afin d'ex\u00e9cuter un bloc de code sous condition que le if qui le pr\u00e9c\u00e8de porte une condition fausse. On peut ainsi \u00e9crire : matin = False if matin : print ( \"Bonjour\" ) else : print ( \"Bonsoir\" ) Mais supposons maintenant qu'il y ait un troisi\u00e8me cas o\u00f9 l'ordinateur devra afficher \"Bonne nuit\" \u00e0 la place, et qu'on utilise un nouveau bool\u00e9en nuit . On pourrait essayer : matin = False nuit = True if matin : print ( \"Bonjour\" ) else : print ( \"Bonsoir\" ) if nuit : print ( \"Bonne nuit\" ) Cela ne fonctionne pas comme nous l'avions pr\u00e9vu, l'ordinateur affiche deux r\u00e9sultats alors que nous n'en n'attendons qu'un seul ! Le probl\u00e8me dans le programme pr\u00e9c\u00e9dent est que l'instruction if nuit est ind\u00e9pendante de l'instruction if matin , alors que \u00e7a ne devrait pas \u00eatre le cas. Pour r\u00e9m\u00e9dier \u00e0 cela, Python propose le mot-cl\u00e9 elif , diminutif de else if (signifiant sinon si). Corrigeons donc le programme pr\u00e9c\u00e9dent : matin = False nuit = True if matin : print ( \"Bonjour\" ) elif nuit : print ( \"Bonne nuit\" ) else : print ( \"Bonsoir\" ) Si matin est vrai, alors on ignore tout le reste et on affiche Bonjour . Sinon, si nuit est vrai alors on ignore le reste et on affiche Bonne nuit . Dans tous les autres cas, on affichera Bonsoir . Notez que vous pouvez mettre autant d'instructions elif \u00e0 la suite d'une instruction if . Cependant else et elif ne sont pas obligatoires pour pouvoir utiliser une instruction if . Rappelons-nous simplement de la structure suivante : if condition : # 1er cas elif autre_condition : # 2e cas elif nouvelle_condition : # 3e cas else : # Tous les autres cas Vous peut-\u00eatre d\u00e9j\u00e0 remarqu\u00e9 les di\u00e8ses # dans les programmes propos\u00e9s. Les di\u00e8ses permettent d'\u00e9crire \u00e0 leur suite des commentaires. Les commentaires sont des suites de caract\u00e8res que l'ordinateur ne prend pas en compte. Ils servent simplement aux \u00eatres humains qui lisent le code, pour pouvoir se rep\u00e9rer ou encore pr\u00e9ciser le r\u00f4le d'une instruction. Avec les connaissances que vous avez acquises, vous devriez \u00eatre capable d'\u00e9crire un programme qui : Challenge Enonc\u00e9 Correction exploite une variable heure qui devrait \u00eatre un entier compris entre 1 et 12 exploite un bool\u00e9en apres-midi qui d\u00e9termine s'il s'agit d'une heure de l'apr\u00e8s-midi ou non Affiche un texte en fonction du moment de la journ\u00e9e obtenu. \"Good morning\" si il est entre 5h et 10h inclus \"Bon app\u00e9tit\" si il est entre 11h et 13h inclus \"Good afternoon\" si il est entre 14h et 17h inclus \"Good evening\" si il est entre 18h et 20h inclus \"Sweet dreams\" si il est entre 21h et 4h inclus heure = 3 apres_midi = True if apres_midi : heure = heure + 12 if heure < 5 or heure > 20 : print ( \"Sweet dreams\" ) elif heure <= 10 : print ( \"Good morning\" ) elif heure < 14 : print ( \"Bon app\u00e9tit\" ) elif heure <= 17 : print ( \"Good afternoon\" ) else : print ( \"Good evening\" ) Mais comment savoir que notre programme est correct pour toutes les heures ? Nous verons cela dans la prochaine partie.","title":"D. L'instruction else et elif"},{"location":"C2-Python/#6-utiliser-des-listes-et-repeter-des-instructions","text":"","title":"6 - Utiliser des listes et r\u00e9p\u00e9ter des instructions"},{"location":"C2-Python/#a-creer-une-liste-et-acceder-a-un-de-ses-elements","text":"Supposons que nous souhaitons une variable qui contienne plusieurs valeurs diff\u00e9rentes, comment proc\u00e8derait-on ? Avec des listes, mon cher ami ! Une liste peut contenir aucune valeur, tout comme elle peut en contenir une, deux, trois, douze, cinquante ou m\u00eame un million. On \u00e9crit le contenu d'une liste entre crochets [] et on s\u00e9pare les valeurs \u00e0 l'int\u00e9rieur par des virgules : liste = [1, 2, 3, 4] liste_vide = [] liste_carres = [1, 4, 9, 16, 25, 36] liste_0 = [0] * 100 liste_fusion = liste + liste_carres Comme nous pouvons le remarquer, nous pouvons \u00e9galement appliquer l'addition et la multiplication sur les listes. L'addition est en fait une op\u00e9ration de concat\u00e9nation entre deux listes, c'est-\u00e0-dire qu'on va fusionner les deux listes en une seule. L'op\u00e9rateur * peut aussi \u00eatre utilis\u00e9. Il sert \u00e0 'r\u00e9p\u00e9ter' le contenu d'une liste un nombre entier de fois, \u00e0 concat\u00e9ner une liste avec une copie d'elle-m\u00eame un nombre entier de fois. Par exemple, ma_liste * 4 revient \u00e0 faire ma_liste + ma_liste + ma_liste + ma_liste . Les listes fonctionnent avec un syst\u00e8me d'indices. C'est-\u00e0-dire que chaqe valeur dans la liste est num\u00e9rot\u00e9e afin de pouvoir l'identifier. A chaque valeur est associ\u00e9e un num\u00e9ro (commun\u00e9ment appel\u00e9 indice) allant de 0 au nombre d'\u00e9l\u00e9ments qu'il y a dans la liste - 1, en accordance avec sa position dans la liste : l'\u00e9l\u00e9ment le plus \u00e0 gauche sera num\u00e9rot\u00e9e 0, celui \u00e0 sa droite aura comme indice 1, le suivant 2, et ainsi de suite. On peut donc acc\u00e9der \u00e0 une valeur de la liste par son indice gr\u00e2ce \u00e0 la notation liste[indice] . Supposons une liste d'entiers et que l'on souhaite additionner la premi\u00e8re valeur avec la 3e, la 5e ainsi que la derni\u00e8re : entiers = [ 29 , 47 , 1 , 18 , - 53 , 10 , 101 , 65 , - 42 ] calcul = entiers [ 0 ] + entiers [ 2 ] + entiers [ 4 ] + entiers [ - 1 ] print ( calcul ) Warning Ne jamais oublier que l'ordinateur commence \u00e0 compter \u00e0 partir de 0 ! Donc il vous faudra soustraire 1 au nombre auquel vous pensez \u00e0 chaque fois que vous souhaitez acc\u00e9der \u00e0 un \u00e9l\u00e9ment d'une liste. Le premier \u00e9l\u00e9ment correspond \u00e0 0, le seizi\u00e8me correspond \u00e0 15, le centi\u00e8me correspond \u00e0 99, etc... Distinguons la notation entiers[-1] . Celle-ci permet d'acc\u00e9der au dernier \u00e9l\u00e9ment d'une liste. Evidemment, on aurait pu aussi \u00e9crire entiers[8] dans le dernier exemple, mais et si le dernier \u00e9l\u00e9ment de la liste est le 3571691e \u00e9l\u00e9ment ? Il est plus simple d'\u00e9crire entiers[-1] En donnant un indice n\u00e9gatif, on acc\u00e8de aux \u00e9l\u00e9ments \u00e0 partir de la droite au lieu de la gauche. Ainsi, entiers[-1] fait r\u00e9f\u00e9rence au dernier \u00e9l\u00e9ment d'une liste (celui le plus \u00e0 droite), entiers[-2] fait r\u00e9f\u00e9rence \u00e0 l'avant-dernier \u00e9l\u00e9ment, entiers[-3] \u00e0 celui \u00e0 sa gauche, et ainsi de suite.","title":"A. Cr\u00e9er une liste et acc\u00e9der \u00e0 un de ses \u00e9l\u00e9ments"},{"location":"C2-Python/#b-methodes-et-fonctions-associees-aux-listes","text":"Pour obtenir la taille d'une liste, on utilise la fonction len , diminutif de length signifiant longueur en anglais. Par exemple len([0, 10, 20, 30]) renvoie 4 car il y a 4 \u00e9l\u00e9ments dans la liste pass\u00e9 en param\u00e8tre (ou argument). La fonction min permet d'obtenir la plus petite valeur d'une liste. Par exemple min([18, 31, 10, 19, 22]) renvoie 10. A l'opposition de la fonction min , la fonction max permet d'obtenir la plus grande valeur d'une liste. Par exemple max([18, 31, 10, 19, 22]) renvoie 31. Pour calculer facilement la somme de toutes les valeurs \u00e0 l'int\u00e9rieur d'une liste, on peut utiliser la fonction sum . Par exemple, sum([18, 31, 10, 19, 22]) renvoie 100. Nous pouvons effectuer un test d'appartenance gr\u00e2ce au mot-cl\u00e9 in . Par exemple, 23 in [19, 87, 45, 23, 12] vaut True car 23 est \u00e0 l'int\u00e9rieur de la liste mentionn\u00e9e. En revanche, 24 in [19, 87, 45, 23, 12] vaut False car il n'y a aucun 24 \u00e0 l'int\u00e9rieur de cette m\u00eame liste. Nous pouvons ajouter un \u00e9l\u00e9ment \u00e0 la fin d'une liste gr\u00e2ce \u00e0 la m\u00e9thode nom_liste.append(valeur) en rempla\u00e7ant nom_liste par le nom que vous avez donn\u00e9 \u00e0 votre liste, et valeur par l'\u00e9l\u00e9ment que vous souhaitez ajouter : factorielles = [ 1 , 2 , 6 , 24 , 120 ] factorielles . append ( factorielles [ - 1 ] * 6 ) print ( factorielles ) Similairement, nous pouvons supprimer un \u00e9l\u00e9ment d'une liste gr\u00e2ce la m\u00e9thode nom_liste.remove(valeur) en rempla\u00e7ant nom_liste par le nom que vous avez donn\u00e9 \u00e0 votre liste et valeur par l'\u00e9l\u00e9ment que vous souhaitez supprimer : factorielles = [ 1 , 2 , 6 , 24 , 120 ] factorielles . remove ( 6 ) print ( factorielles ) On peut obtenir l'indice associ\u00e9 \u00e0 un \u00e9l\u00e9ment gr\u00e2ce \u00e0 la m\u00e9thode nom_liste.index(valeur) en proc\u00e9dant de la m\u00eame mani\u00e8re que les deux m\u00e9thodes pr\u00e9c\u00e9dentes : factorielles = [ 1 , 2 , 6 , 24 , 120 ] indice_24 = factorielles . index ( 24 ) print ( indice_24 ) Enfin, il est possible de supprimer une valeur (tout en ayant l'option de la sauvgarder dans une variable) \u00e0 partir de son indice gr\u00e2ce \u00e0 la m\u00e9thode nom_liste.pop(indice) : factorielles = [ 1 , 2 , 6 , 24 , 120 ] derniere_valeur = factorielles . pop ( - 1 ) print ( factorielles ) print ( derniere_valeur )","title":"B. M\u00e9thodes et fonctions associ\u00e9es aux listes"},{"location":"C2-Python/#c-modifier-une-valeur-a-linterieur-dune-liste","text":"Il est possible de modifier une valeur qui est situ\u00e9e \u00e0 l'int\u00e9rieur d'une liste gr\u00e2ce \u00e0 l'\u00e9criture nom_liste[indice] = nouvelle_valeur en rempla\u00e7ant nom_liste par le nom que vous avez donn\u00e9 \u00e0 votre liste, indice par l'indice associ\u00e9e \u00e0 la valeur que vous souhaitez modifier, et nouvelle_valeur par la nouvelle valeur que doit porter l'\u00e9l\u00e9ment s\u00e9lectionn\u00e9. prix = [ 12.99 , 14.50 , 3.00 , 20.30 , 8.99 ] prix [ 0 ] += 3 prix [ 1 ] -= 5 prix [ 2 ] *= 2 prix [ 3 ] /= 2 prix [ 4 ] = 7.99 print ( prix ) Dans l'exemple \u00e7i-dessus, nous avons modifi\u00e9 individuellement chacun des \u00e9l\u00e9ments de la liste prix . Vous vous demandez peut-\u00eatre \u00e0 quoi corresponds les signes += , -= , *= et /= . Il s'agit d'une affectation particuli\u00e8re. Ces affectations reprennent la valeur initiale de la variable et y effectuent une op\u00e9ration en fonction de l'op\u00e9rateur (+, -, *, /) \u00e9crit. Par exemple : prix = 10 reduction = 2.5 prix = prix - reduction print ( prix ) Fait strictement la m\u00eame chose que : prix = 10 reduction = 2.5 prix -= reduction print ( prix ) C'est le m\u00eame principe pour les autres op\u00e9rateurs : prix = 10 prix = prix + 2 # Signifie strictement la m\u00eame chose que prix = 10 prix += 2 prix = 8 prix = prix * 5 # Signifie strictement la m\u00eame chose que prix = 8 prix *= 5 prix = 24 prix = prix / 6 # Signifie strictement la m\u00eame chose que prix = 24 prix /= 6 Cette technique permet ainsi de simplifier l'\u00e9criture.","title":"C. Modifier une valeur \u00e0 l'int\u00e9rieur d'une liste"},{"location":"C2-Python/#d-la-boucle-for","text":"Il peut arriver qu'on veuille r\u00e9p\u00e9ter la m\u00eame chose un nombre connu de fois. C'est le r\u00f4le de la boucle for . La boucle for traditionnelle en Python s'\u00e9crit : for variable in range ( nb_fois ): # bloc de code \u00e0 r\u00e9p\u00e9ter nb_fois Ne pas oublier qu'il faut remplacer nb_fois par un entier repr\u00e9sentant le nombre de fois que vous souhaitez r\u00e9p\u00e9ter le bloc de code \u00e0 l'int\u00e9rieur de la boucle. Vous pouvez nommer variable comme vous le souhaitez, tant que le nom n'a pas d\u00e9j\u00e0 \u00e9t\u00e9 pris par une autre variable ou fonction existante. Proposons donc une exp\u00e9rience : for i in range ( 10 ): print ( i ) Nous venons donc utiliser la variable i initialis\u00e9e par la boucle dans le bloc associ\u00e9. Attention cependant \u00e0 ne pas l'utiliser en dehors de celle-\u00e7i ! Comme nous pouvons le voir, i commence par prendre la valeur 0, puis elle augmente de 1 jusqu'\u00e0 ce qu'elle atteigne 9. Cela ne vous rappelle rien ? Mais oui ! La fa\u00e7on dont les \u00e9l\u00e9ments d'une liste sont num\u00e9rot\u00e9es, bien s\u00fbr ! Nous verrons plus bas que les boucles for s'av\u00e9rent d'ailleurs efficaces pour parcourir une liste permettant donc d'acc\u00e9der \u00e0 chacun de ses \u00e9l\u00e9ments dans l'ordre et ainsi d'effectuer des m\u00eames op\u00e9rations sur ceux-ci. Autrement, lorsqu'on cr\u00e9e une boucle, nous sommes contraints de sp\u00e9cifier la fin de cette boucle. Mais si nous ne souhaitons pas que la boucle d\u00e9marre \u00e0 0, c'est possible ! Nous pouvons sp\u00e9cifier le valeur initiale de la variable exploit\u00e9e par la boucle et m\u00eame le pas effectu\u00e9 (la valeur que l'on ajoute \u00e0 la variable \u00e0 la fin de chaque it\u00e9ration) avec la syntaxe suivante : for variable in range ( debut , fin , pas ): # Bloc de code \u00e0 r\u00e9p\u00e9ter Voi\u00e7i un cas d'usage qui nous permet d'afficher tous les nombres pairs de 42 \u00e0 120 : for pair in range ( 42 , 120 + 1 , 2 ): print ( pair ) Warning 120 + 1 repr\u00e9sente une certaine importance car il rappelle que le nombre de fin d'une boucle est exclu. La boucle for var in range(10): prendra chaque valeur \u00e0 partir de 0 jusqu'\u00e0 10 mais jamais 10 en lui-m\u00eame !","title":"D. La boucle for"},{"location":"C2-Python/#e-parcourir-une-liste","text":"Reprenons le programme qui affiche un texte diff\u00e9rent en fonction du moment de la journ\u00e9e : heure = 3 apres_midi = True if apres_midi : heure = heure + 12 if heure < 5 or heure > 20 : print ( \"Sweet dreams\" ) elif heure <= 10 : print ( \"Good morning\" ) elif heure < 14 : print ( \"Bon app\u00e9tit\" ) elif heure <= 17 : print ( \"Good afternoon\" ) else : print ( \"Good evening\" ) Nous ne testons qu'un seul cas dans l'exemple \u00e7i-dessus mais et si nous voulions tester plusieurs cas en une seule fois ? Cela est rendu possible gr\u00e2ce \u00e0 l'association d'une liste avec une boucle for . Par exemple, si nous souhaitons tester les valeurs : heures = [ 3 , 10 , 7 , 1 , 5 , 12 ] apres_midi = [ True , False , True , False , True , False ] Les deux listes sont de m\u00eame longueur, une valeur bool\u00e9ene et une heure sont reli\u00e9es par le fait qu'ils partagent le m\u00eame indice dans leur liste respective. Par exemple, heures[2] est une heure de l'apr\u00e8s-midi puisque apres_midi[2] vaut True . Maintenant, il faut effectuer un parcours de liste. Comme les \u00e9l\u00e9ments d'une liste sont num\u00e9rot\u00e9s par des indices croissants, on peut utiliser une boucle for pour g\u00e9n\u00e9rer chaque indice et ainsi avoir acc\u00e8s \u00e0 chacun des \u00e9l\u00e9ments par leur indice. Ce qui nous permet de tester chaque valeur. heures = [ 3 , 10 , 7 , 1 , 5 , 12 ] apres_midi = [ True , False , True , False , True , False ] for i in range ( len ( heures )): if apres_midi [ i ]: heures [ i ] += 12 if heures [ i ] < 5 or heures [ i ] > 20 : print ( heures [ i ], \"Sweet dreams\" ) elif heures [ i ] <= 10 : print ( heures [ i ], \"Good morning\" ) elif heures [ i ] < 14 : print ( heures [ i ], \"Bon app\u00e9tit\" ) elif heures [ i ] <= 17 : print ( heures [ i ], \"Good afternoon\" ) else : print ( heures [ i ], \"Good evening\" ) Le programme \u00e7i-dessus effectue un parcours par indice, mais nous pouvons \u00e9galement effectuer un parcours par \u00e9l\u00e9ment : heures = [ 15 , 10 , 19 , 1 , 17 , 12 ] for element in heures : if element < 5 or element > 20 : print ( element , \"Sweet dreams\" ) elif element <= 10 : print ( element , \"Good morning\" ) elif element < 14 : print ( element , \"Bon app\u00e9tit\" ) elif element <= 17 : print ( element , \"Good afternoon\" ) else : print ( element , \"Good evening\" ) I\u00e7i, on n'acc\u00e8de pas \u00e0 des indices mais directement aux \u00e9l\u00e9ments d'une liste. Cependant, il y a quelques d\u00e9savantages, par exemple on perd la possibilit\u00e9 d'acc\u00e9der \u00e0 des \u00e9l\u00e9ments d'autres listes comme apres_midi . De plus en examinant les deux cas suivants, o\u00f9 nous essayons d'\u00e9lever au cube chaque nombre de la liste : cubes = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] for i in range ( len ( cubes )): cubes [ i ] = cubes [ i ] ** 3 print ( cubes ) cubes = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] for nombre in cubes : nombre = nombre ** 3 print ( cubes ) On remarque que dans le parcours par \u00e9l\u00e9ment, il est impossible d'utiliser la variable pour modifier directement le contenu de la liste. Elle n'est alors pas du tout modifi\u00e9e au contraire du parcours par indice qui permet parfaitement de g\u00e9rer ce genre de cas.","title":"E. Parcourir une liste"},{"location":"C2-Python/#f-listes-par-comprehension","text":"Il existe une derni\u00e8re notion pouvant s'av\u00e9rer utile lors de la manipulation et notamment lors de la cr\u00e9ation de listes : les listes par compr\u00e9hension. Cr\u00e9er des listes par compr\u00e9hension emploie la boucle for et peut-\u00eatre aussi l'instruction if d'une mani\u00e8re inhabituelle. Pour maitriser les listes par compr\u00e9hension, il va vous falloir oublier la syntaxe habituelle des boucles ainsi que des conditions. Mais \u00e0 quoi servent-elles exactement ces listes par compr\u00e9hension ? Il s'agit d'un outil assez puissant qui permet de cr\u00e9er en une seule ligne (au lieu des habituelles trois \u00e0 quatre lignes) une liste avec un contenu qui suit une certaine logique. Assez parl\u00e9, voi\u00e7i un exemple o\u00f9 l'on emploie une liste par compr\u00e9hension afin de cr\u00e9er une liste contenant tous les nombres entiers de 0 \u00e0 99 : entiers = [ entier for entier in range ( 100 )] print ( entiers ) On peut \u00e9galement combiner cela avec des conditions. Par exemple, pour cr\u00e9er une liste contenant les nombres entiers qui sont \u00e0 la fois ni divisible par 2 et ni divisible par 3 de 0 \u00e0 99, on peut \u00e9crire : diviseurs = [ nombre for nombre in range ( 100 ) if nombre % 2 != 0 and nombre % 3 != 0 ] print ( diviseurs ) On peut \u00e9galement cr\u00e9er une liste par compr\u00e9hension \u00e0 partir d'une autre liste au lieu d'utiliser le range : resultats = [ 29 , 2876 , 18 , 27365 , 1762 , 67548930 , 2873649221 , 229 , 2737 , 205 , 27632 , 3764 , 17 ] filtre = [ nombre for nombre in resultats if nombre % 2 != 0 and nombre % 3 != 0 ] print ( filtre ) Les listes par compr\u00e9hension ne sont pas essentielles mais essayons tout de m\u00eame de retenir la syntaxe suivante : liste_comprehension = [ nouvelle_variable for nouvelle_variable in container if condition ] if condition \u00e9tant facultatif et container devant \u00eatre remplac\u00e9 par un range ou bien par un objet qui contient plusieurs \u00e9l\u00e9ments (comme une liste).","title":"F. Listes par compr\u00e9hension"},{"location":"C2-Python/#7-les-boucles-tant-que","text":"","title":"7 - Les boucles tant que"},{"location":"C2-Python/#a-la-boucle-while","text":"Nous avons vu comment cr\u00e9er une boucle qui r\u00e9p\u00e9te des instructions un nombre connu de fois. Mais comment faire dans le cas o\u00f9 on ne sait pas exactement combien de fois une instruction doit \u00eatre r\u00e9p\u00e9t\u00e9e ? C'est l'int\u00e9r\u00eat d'une boucle while . Sa syntaxe est la suivante : while condition : # bloc d'instructions \u00e0 r\u00e9p\u00e9ter Une boucle while r\u00e9p\u00e9te le bloc \u00e0 l'int\u00e9rieur d'elle tant que condition vaut True . Par exemple, nous pouvons diviser un nombre par 2 tant que le r\u00e9sultat obtenu est pairjusqu'\u00e0 finalement obtenir un nombre impair : nombre = 2048 nb_operations = 0 while nombre % 2 == 0 : nombre /= 2 nb_operations += 1 print ( \"Nombre impair final obtenu :\" , nombre ) print ( \"Nombre de divisions n\u00e9cessaires :\" , nb_operations )","title":"A. La boucle while"},{"location":"C2-Python/#b-while-a-faire-et-a-ne-pas-faire","text":"Attention cependant \u00e0 bien faire attention \u00e0 ce que votre while se termine . En effet, une boucle while peut r\u00e9p\u00e9ter des instructions \u00e0 l'infini. Prenons par exemple le cas suivant : nombre = 17 while nombre != 0 : print ( nombre ) nombre -= 2 Ce programme ne s'arr\u00eate jamais ! C'est \u00e0 l'utilisateur de l'arr\u00eater manuellement. En effet, la condition propos\u00e9 plus haut ne sera jamais fausse, car nombre sera toujours diff\u00e9rent de 0. nombre est r\u00e9duit de 2 \u00e0 chaque it\u00e9ration. Le nombres que l'on obtient i\u00e7i appartiennent en fait \u00e0 la formule \\(17 - 2 \\times x\\) . Or, \\(17 - 2x = 0\\) est impossible \u00e0 r\u00e9soudre en sachant que \\(x\\) est un nombre entier (puisque \\(x\\) repr\u00e9sente le nombre d'op\u00e9rations qu'il y a eu lieu). Il faut donc toujours veiller \u00e0 ce que notre boucle while se termine d'une mani\u00e8re ou d'une autre.","title":"B. While : \u00e0 faire et \u00e0 ne pas faire"},{"location":"C2-Python/#c-quand-while-peut-remplacer-une-boucle-for","text":"Avez-vous remarqu\u00e9 que : for indice in range ( 20 ): print ( \"it\u00e9ration\" , indice ) Signifie plus ou moins la m\u00eame chose que : indice = 0 while indice < 20 : print ( \"it\u00e9ration\" , indice ) indice += 1 Nous pouvons m\u00eame g\u00e9n\u00e9raliser que : for variable in range ( debut , fin , pas ): # instructions Equivaut presque \u00e0 : variable = debut while variable < fin : # instructions variable += pas Nous pouvons donc nous dire que la boucle for ne para\u00eet pas si indispensable finalement. Toutefois for est peut-\u00eatre plus facile \u00e0 \u00e9crire et \u00e0 g\u00e9rer qu'une boucle while , bien que while propose plus d'options et accorde plus de contr\u00f4le, nous ne rempla\u00e7erons pas une boucle for par une boucle while si une boucle for est adapt\u00e9e \u00e0 la situation.","title":"C. Quand while peut remplacer une boucle for"},{"location":"C2-Python/#8-chaines-de-caracteres","text":"","title":"8 - Chaines de caract\u00e8res"},{"location":"C2-Python/#a-creation-et-caracteristiques","text":"Nous avions b\u00eatement recopi\u00e9 des mots entre guillemets \u00e0 l'int\u00e9rieur d'instructions print jusque-l\u00e0, mais il faut savoir que ces valeurs portent un nom : il s'agit de cha\u00eenes de caract\u00e8res. Nous avons d\u00e9j\u00e0 cr\u00e9\u00e9 des cha\u00eenes de caract\u00e8res plusieurs fois auparavant, il suffit de mettre entre guillemets une suite de caract\u00e8res : nom_utilisateur = \"Turing le roi du ring\" mot_de_passe = \"ENIGMA\" Les cha\u00eenes de caract\u00e8res sont similaires aux listes dans la mesure o\u00f9 il est possible d'acc\u00e9der \u00e0 un caract\u00e8re d'une cha\u00eene par un indice, et elles poss\u00e8dent tout comme les listes une longueur ce qui rend possible les parcours de chaines de caract\u00e8res : animal = \"elephant\" for i in range ( len ( animal )): print ( \"Le caract\u00e8re situ\u00e9 \u00e0 l'indice\" , i , \"est :\" , animal [ i ]) Grosse diff\u00e9rence avec les listes cependant, c'est que les caract\u00e8res \u00e0 l'int\u00e9rieur des cha\u00eenes de caract\u00e8res ne sont pas modifiables ! Elles sont dites immutables . Par cons\u00e9quent, effectuer l'op\u00e9ration chaine[indice] = nouveau_caractere est impossible : pays_liste = [ \"I\" , \"r\" , \"a\" , \"n\" ] pays_liste [ 3 ] = \"k\" # Possible pays_chaine = \"Iran\" pays_chaine [ 3 ] = \"k\" # Impossible : une erreur se produit","title":"A. Cr\u00e9ation et caract\u00e9ristiques"},{"location":"C2-Python/#b-concatenation-et-format-f-string","text":"Cependant, comme pour les listes, il est possible de concat\u00e9ner deux cha\u00eenes de caract\u00e8res. L'op\u00e9ration * est \u00e9galement disponible : pr\u00e9nom = \"Margaret\" nom = \"Hamilton\" complet = pr\u00e9nom + \" \" + nom print ( complet ) musique = \"do\" musique += \" r\u00e9 mi fa so \" musique *= 5 print ( musique ) Mais supposons que notre chaine de caract\u00e8res ait besoin du contenu d'une variable. Il existe un format sp\u00e9cifique pour cela : le format f-string . Pour sp\u00e9cifier que votre cha\u00eene est un f-string , il suffit d'\u00e9crire un f avant d'ouvrir les guillemets. Puis d'entourer par des accolades {} les variables que vous souhaitez utiliser : annee = 1989 inventeur = \"Tim Berners-Lee\" invention = \"le World Wide Web\" phrase = f \"En { annee } , { inventeur } inventa { invention } .\" print ( phrase ) Et il est plus agr\u00e9able de lire et d'\u00e9crire : print ( f \"En { annee } , { inventeur } inventa { invention } .\" ) Plut\u00f4t que : print ( \"En\" , annee , inventeur , \"inventa\" , invention , \".\" ) Bien que les deux fassent strictement la m\u00eame chose.","title":"B. Concat\u00e9nation et format f-string"},{"location":"C2-Python/#c-methodes-associees-aux-chaines-de-caracteres","text":"Nous l'avons vu auparavant, il est possible d'obtenir la longueur d'une cha\u00eene gr\u00e2ce \u00e0 la fonction len . len(\"Abracadabra !\") renvoie 13 par exemple (les espaces sont consid\u00e9r\u00e9s comme des caract\u00e8res). Il est possible d'obtenir une chaine de caract\u00e8res compos\u00e9es uniquement de majuscules \u00e0 partir d'une cha\u00eene initiale gr\u00e2ce \u00e0 la m\u00e9thode chaine_initiale.upper() . Il est aussi possible d'obtenir une cha\u00eene compos\u00e9e uniquement de minuscules d'une fa\u00e7on similaire, avec la m\u00e9thode chaine_initiale.lower() : chaine_originale = \"ceTtE ChAine EST toUtE DErEGlEe ! IL fauT la RePaRer.\" chaine_majuscules = chaine_originale . upper () chaine_minuscules = chaine_originale . lower () print ( chaine_majuscules ) print ( chaine_minuscules ) Nous pouvons \u00e9galement obtenir une liste \u00e0 partir d'une chaine de caract\u00e8re gr\u00e2ce \u00e0 la m\u00e9thode chaine.split(separateur) . La liste renvoy\u00e9e sera une division de la chaine caract\u00e8re initiale selon un caract\u00e8re s\u00e9parateur separateur . Par exemple, si on souhaite obtenir une liste contenant chaque mot d'une chaine (sachant que les mots sont s\u00e9par\u00e9s des espaces), on peut utiliser un espace comme s\u00e9parateur et \u00e9crire : phrase = \"Alan Turing roi du ring a battu George Boole le maboul\" mots = phrase . split ( \" \" ) print ( mots ) Sinon, nous pouvons mentionner l'ensemble des m\u00e9thodes isdigit , isalpha , isalnum , isascii , isupper , islower qui renvoient True si chacun des caract\u00e8res suivent une r\u00e8gle particuli\u00e8re. Par exemple, chaine.isupper() renvoie True si chacun des caract\u00e8res sont des majuscules. Comme autre exemple, chaine.isdigit() renvoie True si chacun des caract\u00e8res sont des chiffres. chaines = [ \"0011429382\" , \"ALLO\" , \"pizza\" , \" \" , \"Coucou ! Moi, c'est Noah le cacato\u00e8s.\" ] for i in range ( len ( chaines )): if chaines [ i ] . isdigit (): print ( f \"' { chaines [ i ] } ' ne poss\u00e8de que des chiffres\" ) elif chaines [ i ] . isupper (): print ( f \"Tous les caract\u00e8res alphab\u00e9tiques de ' { chaines [ i ] } ' sont des majuscules\" ) elif chaines [ i ] . islower (): print ( f \"Tous les caract\u00e8res alphab\u00e9tiques de ' { chaines [ i ] } ' sont des minuscules\" ) elif chaines [ i ] . isspace (): print ( f \"' { chaines [ i ] } ' est une suite d'espaces\" ) else : print ( f \"' { chaines [ i ] } ' poss\u00e8de une diversit\u00e9 de caract\u00e8res importante\" ) Il existe d'autres m\u00e9thodes, mais elles sont mineures. De plus, elles sont assez simples \u00e0 recr\u00e9er.","title":"C. M\u00e9thodes associ\u00e9es aux chaines de caract\u00e8res"},{"location":"C2-Python/#d-convertir-une-valeur-dun-type-a-lautre","text":"Il peut arriver qu'on souhaite convertir une chaine de caract\u00e8re en un entier, et m\u00eame parfois un entier en une cha\u00eene de caract\u00e8re. Pour cela, on utilise int(objet) pour convertir objet en un nombre entier, et str(objet) afin de convertir objet en une cha\u00eene de caract\u00e8re. chaine = \"45\" entier = 201 conversion_chaine = chaine + str(entier) conversion_entier = entier + int(chaine) print(conversion_chaine) print(conversion_entier) Warning Attention cependant \u00e0 ne pas convertir n'importe quoi ! Par exemple, int(\"girafe\") provoquera une erreur.","title":"D. Convertir une valeur d'un type \u00e0 l'autre"},{"location":"C2-Python/#9-fonctions","text":"","title":"9 - Fonctions"},{"location":"C2-Python/#a-definition-et-cas-dusage","text":"Na\u00efvement, nous avons d\u00e9j\u00e0 utilis\u00e9 plusieurs fonctions telles que print ou len . Quand on veut utiliser une fonction, on \u00e9crit le nom de la fonction toujours suivi par des parenth\u00e8ses () . A l'int\u00e9rieur de ces m\u00eames parenth\u00e8ses, il peut y avoir ou non des arguments . Le nombre d'arguments d\u00e9pend de la fonction utilis\u00e9e. Par exemple, len prend un seul argument obligatoire, qui doit \u00eatre une liste, une cha\u00eene de caract\u00e8res ou tout objet pouvant contenir plusieurs valeurs. Alors que print prend un nombre ind\u00e9fini d'arguments (sachant que chacun des arguments sont s\u00e9par\u00e9s par des virgules). Mais qu'est-ce qu'une fonction exactement ? En programmation, on pourrait d\u00e9finir une fonction comme une suite d'\u00e9tapes qui permet de r\u00e9soudre un probl\u00e8me sp\u00e9cifique. L\u00e0 o\u00f9 le programme r\u00e9soud un probl\u00e8me global, les fonctions r\u00e9solvent chacune un probl\u00e8me mineur pr\u00e9cis. Mais c'est chacune de ces fonctions qui permettent de r\u00e9soudre le probl\u00e8me global ! Un bon programme informatique est en g\u00e9n\u00e9ral d\u00e9coup\u00e9 en plusieurs fonctions, en fait, on pourrait m\u00eame qualifier les fonctions comme des sous-programmes qui permettent de compl\u00e9ter et d'assister le programme principal.","title":"A. D\u00e9finition et cas d'usage"},{"location":"C2-Python/#b-ecrire-une-fonction-et-renvoyer-un-resultat","text":"Passons \u00e0 la pratique. Pour cr\u00e9er une nouvelle fonction, on utilise le mot-cl\u00e9 def en respectant la syntaxe suivante : def nom_fonction (): # instructions Par exemple, si on veut \u00e9crire une fonction qui augmente de 1 la valeur de chaque entier dans une liste : def augmente_1 (): for i in range ( len ( liste_entiers )): liste_entiers [ i ] += 1 liste_entiers = [ 1 , 2 , 3 , 4 , 5 ] print ( liste_entiers ) En ex\u00e9cutant le programme, on remarque que le bloc d\u00e9fini \u00e0 l'int\u00e9rieur de la fonction augmente_1() a \u00e9t\u00e9 omis. En effet, une fonction n'est pas ex\u00e9cut\u00e9e si elle n'est pas appel\u00e9e . On aurait pu mettre n'importe quoi dans la fonction et cela n'aurait rien chang\u00e9 comme par exemple : def augmente_1 (): coucou ; System . out . println ( \"Ce\u00e7i n'est pas du java\" ); liste_entiers = [ 1 , 2 , 3 , 4 , 5 ] print ( liste_entiers ) Pour appeler une fonction (c'est-\u00e0-dire ex\u00e9cuter les instructions \u00e0 l'int\u00e9rieur de la fonction), il suffit d'\u00e9crire le nom de la fonction suivie de parenth\u00e8ses () : def augmente_1 (): for i in range ( len ( liste_entiers )): liste_entiers [ i ] += 1 for _ in range ( 5 ): augmente_1 () print ( liste_entiers ) Evidemment, nous pouvons appeler et r\u00e9utiliser une fonction autant de fois que l'on veut, et c'est \u00e7a qui les rend pratiques ! Une fonction peut \u00e9galement renvoyer un r\u00e9sultat avec le mot-cl\u00e9 return . Par exemple, une fonction qui renvoie une cha\u00eene de caract\u00e8res sans voyelles \u00e0 partir d'une chaine contenue dans la variable chaine_normale : def sans_voyelles (): new_string = \"\" voyelles = \"AEOUIYaeouiy\" for i in range ( len ( chaine_normale )): if not chaine_normale [ i ] in voyelles : new_string += chaine_normale [ i ] return new_string chaine_normale = \"Python, un langage de programmation unique en son genre.\" chaine_speciale = sans_voyelles () print ( chaine_speciale ) Warning Quand une fonction renvoie un r\u00e9sultat, ce r\u00e9sultat devrait \u00eatre stock\u00e9 dans une variable. Il faudrait donc \u00e9crire nom_variable = nom_fonction() plut\u00f4t que simplement nom_fonction() lorsque la fonction renvoie une valeur. Notez \u00e9galement que return marque la fin d'une fonction. M\u00eame s'il reste des instructions apr\u00e8s le mot-cl\u00e9 return , elles sont ignor\u00e9es. Par exemple : def exemple (): if 5 < 10 : print ( \"La fonction va renvoyer True\" ) return True print ( \"Cette instruction a \u00e9t\u00e9 ex\u00e9cut\u00e9e\" ) return False test = exemple () print ( test )","title":"B. Ecrire une fonction et renvoyer un r\u00e9sultat"},{"location":"C2-Python/#c-arguments","text":"Ecrire des fonctions telles que nous les avons \u00e9crites auparavant est une grave erreur cependant. En effet, nous avons utilis\u00e9 des variables \u00e0 l'ext\u00e9rieur de la fonction plut\u00f4t que d'utiliser des arguments dans la conception de nos fonctions. Le probl\u00e8me est que cela rend notre fonction peu flexible et peu adaptable. Les arguments s'\u00e9crivent \u00e0 l'int\u00e9rieur des parenth\u00e8ses lors de la cr\u00e9ation et de l'appel des fonctions. Ainsi pour am\u00e9liorer la fonction augmente_1() : def augmente_1 (): for i in range ( len ( liste_entiers )): liste_entiers [ i ] += 1 liste_entiers = [ 1 , 2 , 3 , 4 , 5 ] print ( liste_entiers ) On cr\u00e9era plut\u00f4t une fonction augmente(n, liste) qui prend en argument la liste qui doit \u00eatre modifi\u00e9e et un nombre n qui repr\u00e9sente l'augmentation de chaque nombre de la liste au lieu d'utiliser directement des valeurs constantes telles que 1 ou des variales externes \u00e0 la fonction comme liste_entiers : def augmente ( n , liste ): for i in range ( len ( liste )): liste [ i ] += n liste_entiers = [ 1 , 2 , 3 , 4 , 5 ] autre_liste = [ 28 , 19 , 1 , 92 ] encore_une = [ - 16 , - 18 , - 43 , - 67 ] augmente ( n = 1 , liste = liste_entiers ) augmente ( n = - 5 , liste = autre_liste ) augmente ( n = 20.5 , liste = encore_une ) print ( liste_entiers ) print ( autre_liste ) print ( encore_une ) Notons que l'\u00e9criture augmente(n = 1, liste = liste_entiers) peut \u00eatre simplifi\u00e9e par augmente(1, liste_entiers) lors de l'appel d'une fonction. Nous avons simplement utilis\u00e9 l'affectation afin de clarifier ce qui se passe (on ex\u00e9cute le bloc contenu dans augmente sachant que n prend comme valeur 1 et liste prend comme valeur liste_entiers , toujours dans le cas pr\u00e9c\u00e9dent). Warning Lors de l'appel d'une fonction, les arguments doivent \u00eatre ordonn\u00e9s dans l'ordre d\u00e9fini par la d\u00e9finition originale de la fonction associ\u00e9e. Par exemple, pour la fonction augmente(n, liste) , augmente(liste_entiers, 1) correspond \u00e0 augmente(n = liste_entiers, liste = 1) et augmente(1, liste_entiers) correspond \u00e0 augmente(n = 1, liste = liste_entiers) . Ainsi augmente(1, liste_entiers) \\(\\not ={}\\) augmente(liste_entiers, 1) . Cependant, si l'ensemble des arguments sont identifi\u00e9s par une affectation explicite nom_argument = valeur , alors l'ordre n'est plus important, ce qui signifie que augmente(n = 1, liste = liste_entiers) \\(=\\) augmente(liste = liste_entiers, n = 1) . Tip Arguments, valeurs par d\u00e9faut : nous pouvons donner une valeur initiale \u00e0 un argument lors de la d\u00e9finition de sa fonction. Par exemple : def deplacer(objet, distance=1): . I\u00e7i nous donnons une valeur par d\u00e9faut \u00e0 l'argument distance , c'est-\u00e0-dire que si l'on omet de donner une valeur \u00e0 distance lors de l'appel de la fonction deplacer , distance prendra automatiquement la valeur 1. Ainsi, deplacer(nuage) fera strictement la m\u00eame chose que deplacer(objet = nuage, distance = 1) dans ce contexte. Challenge Enonc\u00e9 Correction En utilisant des arguments, am\u00e9liorez la fonction sans_voyelles de sorte qu'elle puisse g\u00e9rer n'importe quelle chaine de caract\u00e8re et non pas uniquement chaine_normale . def sans_voyelles ( chaine_initiale ): new_string = \"\" voyelles = \"AEOUIYaeouiy\" for i in range ( len ( chaine_initiale )): if not chaine_initiale [ i ] in voyelles : new_string += chaine_initiale [ i ] return new_string exemple_1 = sans_voyelles ( \"abracadabra !) exemple_2 = sans_voyelles ( \"Les fonctions sont essentielles en programmation\" )","title":"C. Arguments"},{"location":"C2-Python/#d-fonctions-attention-a-la-portee","text":"Tout ce qui a \u00e9t\u00e9 cr\u00e9\u00e9 \u00e0 l'int\u00e9rieur d'une fonction existe uniquement \u00e0 l'int\u00e9rieur de cette fonction. Il n'est plus accessible en dehors. Par cons\u00e9quent un code comme celui-\u00e7i est incorrect : def mystere ( n , ajout = 0 , retrait = 0 , coefficient = 1 , diviseur = 1 , puissance = 1 ): somme = n + ajout - retrait produit = somme * coefficient / diviseur final = produit ** puissance mystere ( 42 , retrait = 5 , puissance = 2 , coefficient = 3 ) print ( final ) I\u00e7i, le programme cherche \u00e0 afficher la valeur de final . Or, final est situ\u00e9 \u00e0 l'int\u00e9rieur de la fonction mystere et n'existe plus \u00e0 l'ext\u00e9rieur de celle-\u00e7i. Une erreur va ainsi se produire. Une solution possible \u00e0 ce probl\u00e8me serait de renvoyer final \u00e0 l'appel de la fonction : def mystere ( n , ajout = 0 , retrait = 0 , coefficient = 1 , diviseur = 1 , puissance = 1 ): somme = n + ajout - retrait produit = somme * coefficient / diviseur final = produit ** puissance return final solution = mystere ( 42 , retrait = 5 , puissance = 2 , coefficient = 3 ) print ( solution ) Similairement, il est impossible de modifier depuis l'int\u00e9rieur d'une fonction une variable qui existe \u00e0 l'ext\u00e9rieur de celle-ci. Ainsi, le programme suivant provoquera une erreur : def reinitialisation (): timer = 0 point_de_vies = 25 score = 0 timer = 14 point_de_vies = 18 score = 346 reinitialisation () N'oublions jamais que, en Python, le r\u00f4le d'une fonction n'est pas de modifier une variable existante. C'est assez important d'\u00eatre conscient de cela lorsqu'on d\u00e9bute en programmation (selon l'exp\u00e9rience du cr\u00e9ateur du site).","title":"D. Fonctions : attention \u00e0 la port\u00e9e !"},{"location":"C2-Python/#10-gestion-de-fichiers","text":"","title":"10 - Gestion de fichiers"},{"location":"C2-Python/#a-ouvrir-et-lire-le-contenu-dun-fichier","text":"Enfin, dernier aspect que nous aborderons pour ce chapitre : la gestion des fichiers avec Python. Python nous permet facilement d'ouvrir et de lire le contenu d'un fichier (sous forme de texte). Mais avant de donner une quelconque instruction Python, nous devons \u00eatre s\u00fbr de comprendre la notion d'arborescence des fichiers . Pour donner une d\u00e9finition simple, l'arborescence est la structure qui d\u00e9finit la position des fichiers dans un syst\u00e8me. Pour trouver un fichier dans une arborescence, nous devons sp\u00e9cifier son chemin. Par exemple C:\\Users\\VICTOR\\Documents\\Travail Nsi\\mkdoc_test\\docs\\C3-Python.md est le chemin permettant d'acc\u00e9der au fichier C3-Python.md . Il y a deux types de chemins. Premi\u00e8rement, le chemin absolu qui part de la racine (ou l'origine) de l'arborescence, comme le chemin vu plus t\u00f4t C:\\Users\\VICTOR\\Documents\\Travail Nsi\\mkdoc_test\\docs\\C3-Python.md dont la racine est i\u00e7i repr\u00e9sent\u00e9e par le C: . Deuxi\u00e8mement, le chemin relatif qui part du dossier actuellement ouvert. Par exemple, en supposant que nous travaillons sur le dossier mkdoc_test , le chemin relatif pour acc\u00e9der \u00e0 C3-Python.md devient alors docs\\C3-Python.md . Nous favoriserons les chemins relatifs au chemins absolus car ils sont plus faciles \u00e0 \u00e9crire. Par ailleurs, vous vous \u00eates peut-\u00eatre d\u00e9j\u00e0 demand\u00e9 l'int\u00e9r\u00eat d'ouvrir un r\u00e9pertoire \u00e0 partir de VS code comme montr\u00e9 \u00e0 la partie 2 de ce chapitre. La r\u00e9ponse est simple. Travailler dans un r\u00e9pertoire nous permet de travailler sur tout un ensemble de fichiers en m\u00eame temps ! A-retenir Lorsqu'on utilise VS code, tous les chemins relatifs auront pour point de d\u00e9part le dossier sur lequel vous travaillez Passons \u00e0 la programmation. Pour ouvrir et lire le contenu d'un fichier existant (par exemple un fichier que vous avez cr\u00e9\u00e9 nomm\u00e9 \"hello.txt\" dans lequel vous avez \u00e9crit ce que vous souhaitez), nous pouvons utiliser la fonction open de Python et la m\u00e9thode read associ\u00e9e aux fichiers : fichier = open ( \"hello.txt\" ) contenu_fichier = fichier . read () fichier . close () print ( contenu_fichier ) Pour obtenir une liste o\u00f9 chacune des lignes du fichier repr\u00e9sentent un \u00e9l\u00e9ment de la liste, on peut utiliser la m\u00e9thode fichier.readlines() : fichier = open ( \"hello.txt\" ) lignes_fichier = fichier . readlines () fichier . close () print ( lignes_fichier )","title":"A. Ouvrir et lire le contenu d'un fichier"},{"location":"C2-Python/#b-fichiers-a-faire-attention","text":"Ne jamais oublier l'instruction fichier.close() \u00e0 partir du moment o\u00f9 l'on a d\u00e9j\u00e0 lu le contenu du fichier. Quand on ouvre un fichier, il faut toujours finir par le fermer. Une alternative \u00e0 fichier.close() serait d'utiliser le mot-cl\u00e9 with : fichier = open ( \"hello.txt\" ) contenu_fichier = fichier . read () fichier . close () print ( contenu_fichier ) Signifie la m\u00eame chose que : with open ( \"hello.txt\" ) as fichier : contenu_fichier = fichier . read () print ( contenu_fichier ) Avez-vous \u00e9galement remarqu\u00e9 les \\n lorsque l'on utilise fichier.readlines() ? \\n est un caract\u00e8re sp\u00e9cial qui signifie un saut de ligne. Ils vont en g\u00e9n\u00e9ral \u00eatre g\u00eanant pour votre programme. Challenge Enonc\u00e9 Correction Essayer de cr\u00e9er une fonction lire_lignes(fichier) alternative \u00e0 la m\u00e9thode readlines() , qui prend en argument fichier : le chemin du fichier que vous souhaitez lire. lire_lignes(fichier) doit renvoyer une liste contenant les diff\u00e9rentes lignes du fichier pass\u00e9 en argument, mais sans les caract\u00e8res \\n def lire_lignes ( fichier ): liste_finale = [ \"\" ] with open ( fichier ) as fic : contenu = fic . read () for char in contenu : if char == \" \\n \" : liste_finale . append ( \"\" ) else : liste_finale [ - 1 ] += char return liste_finale On commence par ouvrir et lire le contenu du fichier en question. On parcourt ensuite le contenu et si le caract\u00e8re est un saut de ligne, on ajoute simplement une chaine de caract\u00e8res vide symbolisant la ligne suivante. Comme nous ajoutons toujours les caract\u00e8res s\u00e9l\u00e9ctionn\u00e9s \u00e0 la derni\u00e8re chaine ajout\u00e9e ( liste_finale[-1] += char ), le contenu du fichier est dans le bon ordre ! Warning Quand on utilise l'instruction read ou readlines , les valeurs renvoy\u00e9es seront toujours des cha\u00eenes de caract\u00e8res. C'est \u00e0 vous de convertir les informations obtenues si n\u00e9cessaire.","title":"B. Fichiers : \u00e0 faire attention"},{"location":"C2-Python/#c-modifier-un-fichier-et-creer-un-nouveau-fichier","text":"Il est possible de modifier le contenu d'un fichier gr\u00e2ce au langage Python. Pour cela, il faut ouvrir un fichier en mode \u00e9criture et utiliser la m\u00e9thode fichier.write() : with open ( \"hello.txt\" , \"w\" ) as fic : fic . write ( \"Coucou !\" ) Le \"w\" dans la fonction open signifie que l'on ouvre notre fichier en mode \u00e9criture. D\u00e9sormais, en ouvrant le fichier hello.txt , vous remarquerez qu'il ne contient qu'une seule chose : \"Coucou !\". Warning L'instruction write \u00e9crase le contenu pr\u00e9c\u00e9dent du fichier. Elle efface int\u00e9gralement le contenu du fichier avant d'\u00e9crire dedans. De plus, il est impossible de lire un fichier qui a \u00e9t\u00e9 ouvert en mode \u00e9criture. Remarquons cependant que write cr\u00e9e un nouveau fichier si le fichier n'existe pas d\u00e9j\u00e0, ce qui peut s'av\u00e9rer tr\u00e8s utile.","title":"C. Modifier un fichier et cr\u00e9er un nouveau fichier"},{"location":"C2-Python/#conclusion","text":"Cette page vous a donc servi de rappel ou d'initiation aux principaux concepts du langage Python. Cependant, le meilleur moyen d'apprendre la programmation, c'est en programmant. C'est par la pratique qu'on apprend le mieux la programmation ! Il est donc fortement conseill\u00e9 de se cr\u00e9er un compte sur le site France IOI et de s'entra\u00eener \u00e0 la programmation ainsi qu'\u00e0 la r\u00e9solution de probl\u00e8mes sur ce dernier.","title":"Conclusion"},{"location":"C2-Python/#glossaire","text":"programme informatique : suite d'instructions logiques destin\u00e9es \u00e0 \u00eatre ex\u00e9cut\u00e9es par un ordinateur. langage de programmation : interm\u00e9diaire entre l'humain et l'ordinateur. Permet la r\u00e9daction de codes sources. code source : l'ensemble des programmes r\u00e9dig\u00e9s et faits pour \u00eatre lus par un \u00eatre humain n\u00e9cessaire \u00e0 la production d'un ex\u00e9cutable en langage machine. ex\u00e9cutable : suite d'instructions \u00e9crites en langage machine pouvant \u00eatre directement ex\u00e9cut\u00e9es par un ordinateur. langage machine : langage binaire (des 0 et des 1) compr\u00e9hensible par l'ordinateur. compilation : proc\u00e9d\u00e9 par lequel un code soure est traduit en une seule fois et en son int\u00e9gralit\u00e9 en langage machine afin de g\u00e9n\u00e9rer un ex\u00e9cutable. interpr\u00e9tation : proc\u00e9d\u00e9 par lequel un code soure est traduit ligne apr\u00e8s ligne en langage machine afin de g\u00e9n\u00e9rer un ex\u00e9cutable. d\u00e9boguer : trouver et corriger les anomalies d'un programme. int : diminutif de integer, qui signifie nombre entier en anglais. float : diminutif de floating point number, qui signifie nombre flottant anglais et qui relate aux nombres \u00e0 virgule. str : diminutif de string, qui signifie cha\u00eene de caract\u00e8res en anglais. Une cha\u00eene de caract\u00e8res est simplement un regroupement de caract\u00e8res, g\u00e9n\u00e9ralement d\u00e9limit\u00e9 par des guillemets en programmation. caract\u00e8re : un caract\u00e8re peut \u00eatre une lettre alphab\u00e9tique miniscule ou majuscule, un chiffre, une virgule, un point, un emoji, etc. C'est une notion plus ou moins abstraite mais pour donner une d\u00e9finition simple, nous dirons qu'un caract\u00e8re constitue l'ensemble des \u00e9l\u00e9ments qu'un ordinateur peut \u00e9crire ou afficher (hors images et couleurs) selon une police et un encodage. encodage : \u00e9tant donn\u00e9 que l'ordinateur ne peut manipuler que des valeurs num\u00e9riques, les caract\u00e8res doivent \u00eatre associ\u00e9s \u00e0 un nombre afin d'\u00eatre manipul\u00e9s par l'ordinateur. C'est le r\u00f4le de l'encodage de caract\u00e8res. Celui-ci permet de repr\u00e9senter individuellement chaque caract\u00e8re parmi une multitude de caract\u00e8res par un nombre. Aujourd'hui, l'encodage de caract\u00e8res le plus r\u00e9pandu est UTF-8. codage RGB : similairement \u00e0 l'encodage de caract\u00e8res, l'ordinateur a besoin de valeurs num\u00e9riques afin de repr\u00e9senter des couleurs. C'est justement le principe du codage RGB (Red Green Blue). Son fonctionnement est simple. Il utilise un triplet de valeurs allant de 0 \u00e0 255 afin de d\u00e9crire une couleur. Chaque valeur repr\u00e9sente dans l'ordre : l'intensit\u00e9 du rouge, l'intensit\u00e9 du vert, et l'intensit\u00e9 du bleu (d'o\u00f9 le nom Rouge Vert Bleu). bit : un seul chiffre binaire (0 ou 1) qui d\u00e9crit une valeur. octet : 8 bits qui d\u00e9crivent une valeur. variable : un identifiant auquel on associe une valeur, les variables sont utilis\u00e9es en informatique pour m\u00e9moriser et suivre l'\u00e9volution d'une information. fonction : similairement aux fonctions math\u00e9matiques, les fonctions peuvent prendre un ou plusieurs arguments. Il s'agit de la d\u00e9finition d'une proc\u00e9dure qui peut ou non renvoyer un r\u00e9sultat. L'int\u00e9r\u00eat de stocker une suite d'op\u00e9rations dans une d\u00e9finition de fonction est de pouvoir la r\u00e9utiliser facilement sans avoir \u00e0 recopier les m\u00eame op\u00e9rations encore et encore. argument : \u00e9galement appel\u00e9 param\u00e8tre, valeur que l'on \u00e9crit g\u00e9n\u00e9ralement entre les parenth\u00e8ses qui suivent une fonction et qui influence le d\u00e9roul\u00e9 d'une fonction et le r\u00e9sultat qu'elle renvoie. module : fichier contenant des fonctions, variables et objets non disponibles initialement pour un langage de programmation. librairie : ensemble de modules. bloc de code : instructions group\u00e9es appartenant \u00e0 une instruction m\u00e8re (une boucle, une fonction, une condition, etc) indentation : syst\u00e8me de d\u00e9limitation de blocs de codes qui utilise les espaces et particuli\u00e8rement la tabulation. condition : valeur bool\u00e9ene que l'ordinateur exploite pour prendre une d\u00e9cision. bool\u00e9en : une valeur bool\u00e9ene est une valeur ne pouvant prendre que deux valeurs (Vrai ou Faux). Le mot vient du math\u00e9maticien George Boole, inventeur de l'alg\u00e8bre du m\u00eame nom. concat\u00e9nation : op\u00e9ration qui rassemble deux valeurs pour les faire fusionner en une valeur de taille plus importante. Exemples : \"conca\" || \"tenation\" = concatenation; 29 || 42 = 2942.","title":"Glossaire"}]}